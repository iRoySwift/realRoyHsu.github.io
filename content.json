{"pages":[{"title":"About Me","text":"一个有梦想的码农！！！","link":"/about/index.html"}],"posts":[{"title":"让Table表格中的td单元格内容过长显示为略号代替","text":"让Table表格中的td单元格内容过长显示为略号代替 123456td { width: 150px; //设置需要固定的宽度 white-space: nowrap; //不换行 text-overflow: ellipsis; //超出部分用....代替 overflow: hidden; //超出隐藏} 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" dir=\"ltr\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media=\"screen\"&gt; td{ border: 1px solid red; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table style=\"border:1px solid red;border-collapse:collapse;table-layout:fixed;width: 250px;\"&gt; &lt;tr&gt; &lt;td&gt;ffffffffffffff&lt;/td&gt; &lt;td&gt;ddddddddddddddd&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;aaaaaaaaaaaaaa&lt;/td&gt; &lt;td&gt;fffffffffffffffff&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;ppppppppppppppp&lt;/td&gt; &lt;td&gt;ooooooooooooooo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2016/11/17/2016-11-17 让Table表格中的td单元格内容过长显示为略号代替/"},{"title":"Atom插件","text":"如何评价 Github 发布的文本编辑器 Atom？ 知乎这篇文章能让你更好的了解Atom 为什么选择Atom 来看看官方怎么说吧. Atom的简单入门就不科普了，想了解来看看这篇文章吧：Atom基础使用 Atom插件官网地址： atom.io目录 简单交代背景 常用快捷键 推荐Packages 需慎重使用的Packages 推荐Themes 聊聊Settings 高级篇 - 写个Atom Package 小结 FAQ 简单交代背景 如何评价 Github 发布的文本编辑器 Atom？ 知乎这篇文章能让你更好的了解Atom 为什么选择Atom 来看看官方怎么说吧. Atom的简单入门就不科普了，想了解来看看这篇文章吧：Atom基础使用 常用快捷键 Sublime常用的功能Atom应该都有，比如俺最喜欢的多光标选中和多处选取; 和Sublime一样的快捷键俺这里就不再多浪费时间列举了哈； 在tree-view的Keybindings里面有非常详细的说明，都是针对Tree操作的 显示或隐藏目录树123456789101112131415161718192021222324252627282930313233- ```ctrl-0``` 焦点移到目录树- ```fn-F2```(选择tree后) 修改文件/文件夹名称- ```ctrl-shift-M``` Markdown预览，这非常方便俺这种写手- ```ctrl-alt-b``` 安装[atom-beautify](https://atom.io/packages/atom-beautify)后可使用，格式化代码- ```ctrl-` ``` 安装[terminal-panel](https://atom.io/packages/terminal-panel)后可使用，调起CLI- ```ctrl-shift-U``` 调出切换编码选项- ```cmd-t```或```cmd-p``` 查找文件- ```alt-cmd-[``` 折叠- ```alt-cmd-]``` 展开- ```alt-cmd-shift-{``` 折叠全部- ```alt-cmd-shift-}``` 展开全部- ```ctrl-m``` 相应括号之间，html tag之间等跳转- ```alt-shift-S``` 查看当前可用代码片段更多快捷键去Settings里面查看，如下图![](https://realroyhsu.github.io/Img/atompackage/keybindings.png)&lt;h3 id=&quot;301&quot;&gt;推荐Packages&lt;/h3&gt;&gt; 很多时候，安装后不能及时就生效，需要重启Atom，这块比较讨厌，略搓:(- [activate-power-mode](https://atom.io/packages/activate-power-mode) 装逼必备，效果相当赞。PS：最新的版本(0.5.2)有升级性能，卡顿效果小很多了- [linter](https://atom.io/packages/linter)+[linter-eslint](https://atom.io/packages/linter-eslint) 必备；代码校验工具- [autocomplete-paths](https://atom.io/packages/autocomplete-paths) 填写路径的时候有Sug提示- [pigments](https://atom.io/packages/pigments) 让颜色相关的字符，在任何文件下都可以展示对应的高亮，强烈推荐- [color-picker](https://atom.io/packages/color-picker) 推荐；写CSS时非常方便的调色板- [docblockr](https://atom.io/packages/docblockr) 注释也优雅，一款用于写注释的插件。支持常见的各种语言- [emmet](https://atom.io/packages/emmet) 必备；前端开发必备，谁用谁知道，入门地址：[Emmet使用手册](http://www.w3cplus.com/tools/emmet-cheat-sheet.html)- [file-icons](https://atom.io/packages/file-icons) 推荐：让文件前面有彩色图片，看着非常享受- [csscomb](https://atom.io/packages/atom-csscomb) 推荐前端使用。可以把CSS按照一定的顺序重排，看起来会更友好。- [git-plus](https://atom.io/packages/git-plus) Git插件；得先配置邮箱和用户名- [git-time-machine](https://atom.io/packages/git-time-machine) Git党必备；可以查看当前编辑文件的 ci history，diff 版本间改动；快捷键 ```alt-t javascript-snippets 推荐；各种缩写，值得拥有；当然，俺用的最多的是cl命令:) atom-beautify 必备；格式化代码的，快捷键ctrl-alt-b esformatter 统一代码格式用的 Minimap 推荐；就是Sublime右边那一竖块，显示缩小版的代码 需慎重使用的Packages esformatter 统一代码格式用的。但是，偶尔脑残，经常报些奇葩的错误，不知道最新版有木有改善，但是我们有了更好的格式化代码的办法，使用 linter + linter-eslint atom-beautify 说说我遇到的情况，如果设置了保存时格式化，当文件比较大的时候，会有很明显的卡顿，所以我这已经不使用这个插件了 activate-power-mode 装逼效果不用多说，但是无论如何优化，基于Browser搞动画所依赖的方面太多了，所以偶尔脑残和卡顿你得习惯:) 推荐Themes 其实Atom默认的主题就已经非常小清新、文艺范儿，但前端对美好事务的追求是永不停歇的… 提醒一点：Atom的主题是区分 UI主题和语法主题 seti-syntax 每个文件前的icons是最大亮点 atom-material-ui + atom-material-syntax 颜色正 monokai 偶尔想用回Sublime的时候可以用:) Dracula 这个主题不光有 Atom版本的，还有 Sublime, Vim, iTerm, Zsh等等编辑器都存在 Lucario 暗色系主题，支持 Vim, Atom, Sublime Text, TextMate, Terminal.app, iTerm, Xcode and XTerm 聊聊Settings 在这儿聊些很有用的设置 上图红框中的选项 可以隐藏一些需要忽略的文件 上图红框中的选项 可以实现Sublime选择文件的效果。不勾选时，点击一个文件就是打开文件；勾选后，双击文件才是打开文件 上图红框中的选项 会再保存时让代码格式化，比如去掉不需要的空格、换行之类 高级篇 - 写个Atom Package 文档地址：Package: Word Count","link":"/2017/05/20/2017-05-20 Atom插件/"},{"title":"Emmet自动补全React中jsx","text":"This guide assumes you have the emmet and language-babel packages already installed in AtomEmmet自动补全React中jsx Emmet自动补全React中jsx This guide assumes you have the emmet and language-babel packages already installed in Atom 1.Open the keymap.cson file by clicking on Atom -&gt; Keymap… in the menu bar 2.Add these lines of code to your keymap: 12&apos;atom-text-editor[data-grammar~=&quot;jsx&quot;]:not([mini])&apos;: &apos;tab&apos;: &apos;emmet:expand-abbreviation-with-tab&apos; 3.Now open a file with JSX code, type div.myclass, press tab and it should autocomplete to ! (if it’s not properly syntax highlighted, select Babel ES6 JavaScript or JSX as the syntax, this won’t work otherwise)","link":"/2017/06/27/2017-06-27 Emmet自动补全React中jsx/"},{"title":"Sublime3 React、JSX 代码美化--[Prettier]","text":"最近一直用Sublime写React项目，但是jsx语法格式化一直让我头疼。尝试了JsFormat、jsfmt、HTML/CSS/JS pretty、esformatter等都没有完美的解决我的问题,结果惨不忍睹： 最近一直用Sublime写React项目，但是jsx语法格式化一直让我头疼。尝试了JsFormat、jsfmt、HTML/CSS/JS pretty、esformatter等都没有完美的解决我的问题结果惨不忍睹： Prettier官网 JsPrettier is a Sublime Text Plug-in for Prettier, the opinionated code formatter.网传facebook也是在用它优化React项目 开始安装插件 -g 全局安装npm install -g prettier sublime text3 直接在package control搜索prettier下载，打开它的User配置项加入如下保存即可。 修改配置文件Preferences&gt;PackageSettings&gt;JsPrettier&gt;Settings User 1234567891011121314151617181920212223{ \"debug\": false, \"prettier_cli_path\": \"C:/Users/njwb/AppData/Roaming/npm/node_modules/prettier/bin-prettier.js\", \"node_path\": \"C:/Program Files/nodejs/node.exe\", \"auto_format_on_save\": false, \"auto_format_on_save_excludes\": [], \"allow_inline_formatting\": false, \"custom_file_extensions\": [], \"max_file_size_limit\": -1, \"additional_cli_args\": {}, \"prettier_options\": { \"printWidth\": 80, \"singleQuote\": false, \"trailingComma\": \"none\", \"bracketSpacing\": true, \"jsxBracketSameLine\": false, \"parser\": \"babylon\", \"semi\": true, \"requirePragma\": false, \"proseWrap\": \"preserve\", \"arrowParens\": \"avoid\" }} “prettier_cli_path”: 是你全局安装prettier插件的路径“node_path”: 是你nodejs安装的路径 在项目根目录下面建一个 .prettierrc 文件,并配置1234567891011{ \"printWidth\": 120, // 换行字符串阈值 \"semi\": true, // 句末加分号 \"singleQuote\": true, // 用单引号 \"trailingComma\": \"none\", // 最后一个对象元素加逗号 \"bracketSpacing\": true, // 对象，数组加空格 \"jsxBracketSameLine\": false, // jsx &gt; 是否另起一行 \"arrowParens\": \"avoid\", // (x) =&gt; {} 是否要有小括号 \"requirePragma\": false, // 是否要注释来决定是否格式化代码 \"proseWrap\": \"preserve\" // 是否要换行} 修改快捷键1234{ \"keys\": [\"ctrl+shift+j\"], \"command\": \"js_prettier\"} 如果按照本教程出现插件还是无法使用,请输入Ctrl + ·，查看控制台是否有报错它会提示你哪里有错误，Prettier官网 错可能情况有： React文件中，有单标签没有闭合：img input 配置文件中符号为中文 完美的解决了React格式化问题","link":"/2018/09/02/2018-09-02 Sublime3 React、JSX 代码美化--[Prettier]/"},{"title":"关于jquery中的ajax调取数据成功回调函数，失败回调函数","text":"通常，ajax调取数据，在pc端的时候，我们不需要考虑断网情况，所以很多情况下我们都只需要如下格式： 通常，ajax调取数据，在pc端的时候，我们不需要考虑断网情况，所以很多情况下我们都只需要如下格式： 即可实现ajax调取后台数据，我这里用的是jsonp跨域调取的数据。 但是在移动端就不一样了，在app上，我们通常要考虑手机断网的情况，而我们上一段的代码中，error只是提示我们报错的原因或状态，并不能执行我们网络错误以后的回调函数，所以我们需要改动一下以上的代码。如下： 我用红线框出来的部分需要注意，在断网情况下，必须要设定timeout的值，你可以根据自己想要设定的时间，即表示在加载超过多少秒后就判断为断网了，在这里我设定的值是5秒，即在五秒后若没有获取到数据就进入失败回调函数。同时async:true必须设定为异步的形式，这里我没有进行设置即默认是异步的， 那么我们就可以在失败回调函数中进行我们想要的操作了。","link":"/2018/09/27/2018-09-27 关于jquery中的ajax调取数据成功回调函数，失败回调函数/"},{"title":"SSH远程连接Google的Compute Engine","text":"在您的工作站上打开一个终端，再使用 ssh-keygen 命令生成新的密钥。指定 -C 标志以添加一条带有您的用户名的注释。 1、ssh-keygen -t rsa -f ~/.ssh/[KEY_FILENAME] -C [USERNAME] 其中： [KEY_FILENAME] 是您要用于 SSH 密钥文件的名称。例如，文件名 my-ssh-key 生成一个名为 my-ssh-key 的私钥文件和一个名为 my-ssh-key.pub 公钥文件。 [USERNAME] 是您要为其应用此 SSH 密钥的用户。 该命令生成一个 SSH 私钥文件和一个匹配的 SSH 公钥，公钥结构如下所示：ssh-rsa [KEY_VALUE] [USERNAME] 其中：[KEY_VALUE] 是您生成的密钥值。[USERNAME] 是此密钥要应用到的用户。 2、限制对您的私钥的访问，以便只有您能读取此密钥，且所有人都不可向其写入。 chmod 400 ~/.ssh/[KEY_FILENAME] 其中 [KEY_FILENAME] 是您用于 SSH 密钥文件的名称。 3、要使用 ssh 连接到实例，请执行以下操作： 1、使用其中一个可用选项为实例提供 SSH 公钥。 1、cat google.pub 2、生成的公钥内容要复制出来 3、粘贴到Compute Engine的 元数据中 2、在控制台中，查找要连接到的实例的外部 IP 地址。转到您的实例列表。 3、在终端中，使用 ssh 命令和 SSH 私钥文件连接到实例。指定您的用户名和您要连接到的实例的外部 IP 地址。 ssh -i [PATH_TO_PRIVATE_KEY] [USERNAME]@[EXTERNAL_IP_ADDRESS] 其中：[PATH_TO_PRIVATE_KEY] 是您的 SSH 私钥文件的路径。[USERNAME] 是连接到实例的用户的名称。在创建 SSH 密钥时，就指定了该 SSH 公钥的用户名。如果实例具有该用户的有效 SSH 公钥，并且您拥有与之匹配的 SSH 私钥，则您可以以该用户的身份连接到此实例。[EXTERNAL_IP_ADDRESS] 是您的实例的外部 IP 地址。如果连接成功，您就可以使用终端在您的实例上运行命令。完成操作后，可使用 exit 命令断开与实例的连接。","link":"/2018/10/28/2018-10-28 SSH远程连接Google的Compute Engine/"},{"title":"使用 webpack 手动搭建一个基于 vue 的单页面应用","text":"使用 webpack 手动搭建一个基于 vue 的单页面应用 创建项目,进入目录，运行下面命令，可以生产 package.json 文件 npm init 创建项目需要的基础文件和文件夹 安装 webpack 以及一些其他开发依赖 webpack-dev-server 热加载依赖 html-webpack-plugin 打包 html 模板依赖 添加 babel-loader babel-core babel-preset-env 依赖包，支持 es6 npm i --save-dev webpack webpack-cli webpack-dev-server html-webpack-plugin babel-core babel-loader babel-preset-env css-loader style-loader vue-loader vue-template-compiler 安装项目依赖 npm i --save vue vue-router vuex 配置 webpack-config.js 1234567891011121314const path = require('path');module.exports = { mode: 'development', // 入口文件，用绝对路径，保证我们不因为路径发生错误 //path.join(__dirname, 'src/index.js')中__dirname表示当前文件的路径，path.join就是将当前文件的路径跟'src/index.js'拼接起来，形成一个绝对路径 entry: { app: './src/app.js', //入口js }, output: { //打包输出目录 path: path.join(__dirname, '../dist'), //打包输出路径 filename: '[name].js', //打包输出文件名字 name对应 entry 里面的 app },}; 在 package.json 里面添加 打包命令，添加 –config 指向 webpack.config.js 在命令面板中输入 npm run build 会在项目中生成一个 dist 文件夹 已经生成好打包文件，但是只有 js，没有 html 引入 html-webpack-plugin 插件，让 webpack 把 html 也打包进去 安装 cross-env 这个包,这个包能够使得在不同的平台执行同一个 script,并修改脚本 npm i --save-dev cross-env 在 webpack.dev.config.js 中配置 dev-server 构建本地 node 服务器，添加热部署功能 配置 loader ，添加 css, js, vue loader，注意，loader 加载有先后顺序，后加载的放开头，要先了解每个 loader 之间的依赖关系 修改 app.js、index.html、App.vue 文件, app.js 文件中注册组件的 components 写错了 运行npm run dev,开启服务，发现报错 开启热加载 webpack 不认识 vue 文件，Vue-loader 在 15.*之后的版本都是 vue-loader 的使用都是需要伴生 VueLoaderPlugin 的, 解决问题 继续报错，是因为我们只加载了 vue.runtime.esm.js 文件 运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量 30%，只有 17.14 Kb min+gzip 大小。 解决方法一:给 Vue 文件起别名(推荐) 解决方法二:使用 render 函数 结果 路由配置 新建./src/components/HelloWorld.vue 文件 新建./src/router/index.js 文件 修改 App.vue 与入口文件 index.js 文件 在 APP.vue 中创建路由容器","link":"/2019/03/25/2019-03-25 使用webpack手动搭建一个基于vue的单页面应用/"},{"title":"js对象，set和get方法 的三种实现形式","text":"ES5 Get [[Getter]] 读取方法 Set [[Setter]] 设置方法 ES5 新增 “属性描述符”，可针对对象属性的特性进行配置。 数据属性 Configurable 可配置（可删除）？[true|false] Writable 可写？ [true|false] Value 值？默认 undefined 访问器属性 Get [[Getter]] 读取方法 Set [[Setter]] 设置方法 访问器属性优先级高于数据属性 访问器属性会优于 writeable/value 获取属性值时，如果对象属性存在 get()，会忽略其 value 值，直接调用 get()； 设置属性值时，如果对象属性存在 set()，会忽略 writable 的设置，直接调用 set(); 访问器属性日常应用： 属性值联动修改（一个属性值修改，会触发另外属性值修改）； 属性值保护（只能通过 set() 制定逻辑修改属性值） 定义属性特性 Object.defineProperty() 定义单个属性 Object.defineProperties() 定义多个属性 第一种方式，直接在对象内设置。如代码所示。 12345678910111213let book = { name: '乐园', get nameGet() { console.log(this.name, 'Get'); return this.name; }, set nameSet(value) { console.log(value, 'set'); this.name = value; },};book.nameSet = '开心';console.log(book.nameGet, book); 第二种方式，使用 Object.defineProperty()和 Object.defineProperties()进行设置 12345678910111213141516171819202122232425262728293031323334let book = {};Object.defineProperties(book, { // _name: { // configurable: true, // writable: true, // value: \"roy\" // }, name: { get: function() { console.log(this, 'get'); return this._name; }, set: function(value) { console.log(value, 'set'); this._name = value; }, },});// Object.defineProperties(book, {// _name: {// configurable: true,// writable: true,// value: \"roy\"// },// get name() {// console.log(this, \"get\")// return this._name// },// set name(value) {// this.name = value;// }// })book.name = 34;console.log(book.name); 第三种方式：使用原型方法进行设置 12345678910111213let book = { name: '乐园',};book.__defineGetter__('nameGet', function() { console.log(this.name, 'Get'); return this.name;}), book.__defineSetter__('nameSet', function(value) { console.log(value, 'set'); this.name = value; });book.nameSet = '开心';console.log(book.nameGet);","link":"/2019/01/11/2019-01-11 js对象，set和get方法 的三种实现形式/"},{"title":"this指向和get、set中this指向","text":"1.全局环境2.事件处理函数3.函数内部4.getter 和 setter 中 this 1.全局环境 window 123&lt;script&gt; console.log( this ); //Window&lt;/script&gt; 1234567var box = document.getElementById(\"box\");box.onclick = function(){ setTimeout( function(){ console.log( this ); // window this.style.backgroundColor = \"red\"; },1000 )} 2.事件处理函数 DOM 事件处理函数 12345var box = document.getElementById(\"box\");box.onclick = function(){ console.log( this ); // 事件处理函数中的 this, 该事件由谁触发,this指的就是谁 //此处this返回：&lt;div id=\"box\" &gt;div&lt;/div&gt;} 内联事件处理函数 1234&lt;div id=\"box\" onclick=\"console.log( this )\" &gt;div&lt;/div&gt;&lt;!-- 此处this指向：&lt;div id=\"box\" onclick=\"console.log( this )\" &gt;div&lt;/div&gt; --&gt;&lt;div id=\"box\" onclick=\"( (function(){console.log( this )})() )\" &gt;div&lt;/div&gt;&lt;!-- 此处this指向：window --&gt; 3.函数内部 1.函数直接执行 非严格模式下 默认指向全局对象 浏览器 12345function fn(){ console.log(this);}fn();//此处this，指向windowwindow.fn();//此处this，指向window node node交互界面中 js文件中 严格模式下(前面省略window,浏览器严格模式支持) undefined 123456function fn(){ \"use strict\" console.log(this);}fn();//此处this，打印 undefinedwindow.fn();//此处this，指向window 2.call,apply和bind 把 this 的值从一个执行环境传入另一个执行环境 call apply 改变指向同时，运行函数 call 和 apply 的参数差异:apply 可以传【数组】 如果传入的不是对象会调用相对的构造函数,进行隐式转换 1234567function fn(m,n){ console.log( this.a,m,n );}fn.call( {a: 1},2,3 );// 函数.call 会直接调用该函数.// 并且call 的 第 0个参数就是 函数执行时候的this 指向第0个对象// 后面的参数是 函数执行的时候的参数 bind bind只改变指向，不会调用方法 返回一个新函数,内部this指向被修改 只会改变一次 1234567891011121314151617181920function fn(){ console.log( this.a )}fn();// this指向undefinedvar fn1 = fn.bind( {a: 2} );var fn2 = fn.bind( {a: 3} );var fn3 = fn.bind( {a: 4} );console.log( fn1 );//ƒ fn(){// console.log( this.a )// }fn1();//打印 2fn2();//打印 3fn3();//打印 4var fn4 = fn1.bind( {a:100} );fn4();//打印 2 bind只会改变一次 , 所以 还是打印 第一次bind的对象 传入数字，打印数字类型 12345function fn(){ console.log( this )}var fn1 = fn.bind(1);fn1(); //this指向 Number 3.箭头函数内部 与定义时的环境中 this 一致 点击元素定时改变 1234567891011121314&lt;div id=\"box\"&gt;box&lt;/div&gt;&lt;script&gt; var fn = ()=&gt;{ console.log( this ); // this指向window } fn(); box.onclick = function(){ console.log( this );// this指向box setTimeout( ()=&gt;{ // 箭头函数中，this指向与定义时的环境中 this 一致 //如果这个是function， this.style.backgroundColor，会报错，因为this指向window； 而window原型中没有backgroundColor this.style.backgroundColor = \"red\";//this指向box },500 ) }&lt;/script&gt; bind,call 不能修改其内部指向 全局中定义箭头函数 全局对象 12345var fn = ()=&gt;{ console.log( this )//this指向window}var fn1 = fn.bind( {} );//bind,call 不能修改其箭头函数内部指向fn1();//this指向window 对象内函数定义箭头函数 对象内部this指向window 1234567891011121314var a = 1;var obj = { a: 2, b:this, fn1: ()=&gt;{ console.log( this.a ) }, fn2: function(){ console.log( this.a ) }}console.log(obj.b);//打印window 对象内部this指向windowobj.fn1();//打印1 this指向windowobj.fn2();//打印2 this指向obj 对象内函数返回箭头函数 function函数，原则是谁调用指向谁 箭头函数，原则是在哪定义，this指向谁，并且不能被call、bind的改变指向 与上面中有所区别，对于箭头函数，return 箭头函数，里面this指向是不变的 1234567891011121314151617181920212223242526272829303132333435363738394041424344var a = 1;var obj = { a: 2, fn1: function(){ console.log( this.a )//谁调用指向谁 return function(){ console.log( this.a )//谁调用指向谁 } }, fn2: ()=&gt;{ console.log(this.a);//this指向window return ()=&gt;{ console.log( this.a );//this指向window } }, fn3: ()=&gt;{ console.log(this.a);//this指向window return function(){ console.log( this.a );//谁调用指向谁 } }, fn4: function(){ console.log(this.a);//谁调用指向谁 return ()=&gt;{ console.log( this.a );//this指向 fn4中，与function内部this指向一样 } }}var innerFn1 = obj.fn1();//打印 2console.log(innerFn1);//这里 innerFn1 = return出来的 functioninnerFn1();//打印 1 this指向window，谁调用指向谁var innerFn2 = obj.fn2();//打印 1innerFn2();//打印1 this指向windowvar innerFn3 = obj.fn3();//打印 1innerFn3();//打印1 this指向window，谁调用指向谁var innerFn4 = obj.fn4();//打印 2console.log(innerFn4);//这里 innerFn4 = return出来的 ()=&gt;{}innerFn4();//打印 2 this指向 fn4中，与function内部this指向一样 4.对象方法内部 当函数作为对象里的方法被调用时 调用该函数的对象 123456789var a = 1;var obj = { a: 2, fn: function(){ console.log( this.a ) }}obj.fn();//2obj.fn.bind({a: \"momo\"})();//momo 对象后续附属上的方法调用 调用该函数的对象 1234567891011121314var obj = { a: 1};var fn = function(){ console.log(this.a)}obj.fn = fn;//与上面中，实际一样，对象赋值，指向同一个对象obj.fn();//1//-------------------------------------var fn1 = ()=&gt;{ console.log(this.a)}obj.fn1 = fn1;obj.fn1();//undefined 箭头函数this定义时，就确定指向 作为函数内嵌套多层的方法调用 就近绑定 12345678910111213var a = 1;var obj = { a: 2, o: { a: 3, fn: function(){ console.log(this.a) } }};obj.o.fn();//3 就近绑定var temp = obj.o.fn;temp();//1 谁调用this指向谁 5.构造函数中 构造函数中没有显式return 12345function Fn(){ this.a = 10;}var f = new Fn();//this指向实例化过程，创建出来的对象 f console.log( f );//{a: 1, fn: ƒ} 构造函数中显式return return 对象 return 非对象 1234567function Fn(){ this.a = 10; //return 1; //返回非 null 的对象,那么实例化结果就是返回出的对象 Fn {a: 10} return {}; //返回非 null 的对象,那么实例化结果就是返回出的对象 {}}var f = new Fn();//this指向实例化过程，创建出来的对象 f console.log( f ); 6.原型链上函数 调用该函数的对象 1234567891011var p = { a: 1, fn: function(){ console.log( this.a ) }}var c = Object.create( p );//以p对象来复制一个对象console.log(c);//打印空对象{}console.log( c.__proto__ );//打印p对象 {a: 1, fn: ƒ}console.log( c.a );//打印1 c没有a属性，会往原型链上找c.fn();//打印1 c调用fn方法，this指向c对象，但是c上没有a属性，会往原型链上找 4.getter 和 setter 中 this get 访问 set 设置 123456789101112131415var obj = { n: 1, m: 2, get sum(){//拦截 在控制台中，obj.sum console.log( \"正在尝试访问 sum...\" ) // return 2 return this.n+this.m//这里this指向obj }, set sum(zm){//拦截 在控制台中，obj.sum = 24 console.log( \"正在设置 sum...\" ); this.n = zm/2;//这里this指向obj this.m = zm/2; }}// console.log( obj.sum )","link":"/2018/11/04/2018-11-04 this指向和get、set中this指向/"},{"title":"了解Webpack","text":"本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 1、熟悉 webpack 创建项目文件（webpack） npm init; 初始化 package.json 安装生产依赖 lodash npm install –save lodash 安装开发依赖 gulp npm install –save-dev gulp 2、开始安装配置 webpack 创建 webpack.config.dev.js 配置文件 安装项目依赖 npm install –save-dev webpack@4 或 npm i -D webpack 配置 webpack.config.js 文件前，path 入口，先要有项目文件夹 src 建 src 文件夹，放 App.js 项目入口,配置到 webpack.config.js 的入口中；output;项目的绝对路径，所以要 path 模块来获取;(dirname)当前文件所在的绝对路径;path.resolve([from …], to) 建立项目出口文件 dist 生成/assets，放置我们打包的文件 使用 filename: ‘[name].[chunkhash].js’, 打包时,热替换影响了 chunkhash 的使用，你要确保 hotModuleReplacementPlugin(）函数没在生产环境下执行， chunkname 我的理解是未被列在 entry 中，却又需要被打包出来的文件命名配置。什么场景需要呢？我们项目就遇到过，在按需加载（异步）模块的时候，这样的文件是没有被列在 entry 中的，如使用 CommonJS 的方式异步加载模块： 1234567891011121314//请求一个path模块const path = require('path');//到出module.exports = { mode: 'development', //开发模式 entry: './src/App.js', output: { //打包输出目录 path: path.join(__dirname, '../dist'), //打包输出路径 filename: '[name].[chunkhash].js', //打包输出文件名字 name对应 entry 里面的 app chunkFilename: '[id].[chunkhash].js', // publicPath: '/', // 通过devServer访问路径 },}; 修改 package.json 文件 12345678910111213141516171819{ \"name\": \"p\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"webpack.config.js\", //配置文件 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack --config webpack.config.dev.js\" //运行 }, \"author\": \"Roy\", \"license\": \"ISC\", \"dependencies\": { \"lodash\": \"^4.17.5\" }, \"devDependencies\": { \"gulp\": \"^3.9.1\", \"webpack\": \"^4.2.0\" }} 3、 Pluginhtml-webpack-plugin 利用 webpack 插件来创建 html 文件 npm i -D html-webpack-plugin package.json 里面的配置为 123456789101112131415161718{ \"name\": \"wpack\", \"version\": \"0.0.1\", \"description\": \"1、创建项目文件（webpack）\", \"main\": \"webpack.config.dev.js\", \"dependencies\": {}, \"devDependencies\": { \"html-webpack-plugin\": \"^3.1.0\", //创建html文件的插件 \"webpack\": \"^4.2.0\", \"webpack-cli\": \"^2.0.13\" }, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack --config webpack.config.dev.js\" //运行 }, \"author\": \"Roy\", \"license\": \"ISC\"} 然后在 webpack.config.dev.js 里面配置，让插件生效 12345678910111213141516171819202122//请求一个path模块const path = require('path');//请求自动创建html插件const HtmlWebpackPlugin = require('html-webpack-plugin');//到出module.exports = { entry: './src/App.js', output: { filename: 'main.js', path: path.resolve(__dirname, 'dist/assets'), publicPath: '/assets', }, mode: 'development', plugins: [ //plugins数组 new HtmlWebpackPlugin({ filename: 'index.html', template: './src/index.html', inject: true, //是否引用打包好的js }), //调用插件 ],}; 然后打包 npm run dev 以 template: ‘./src/index.html’为模板，生成 filename: ‘index.html’, CleanWebpackPlugin 删除打包文件 clean-webpack-plugin npm i -D clean-webpack-plugin 修改 webpack 配置 123456789//请求清除文件的插件const CleanWebpackPlugin = require('clean-webpack-plugin');plugins: [ new HtmlWebpackPlugin({ filename: '../index.html', //让生成的文件，往上返一层 template: './src/index.html' }), new CleanWebpackPlugin([\"dist\"]) //自动删除文件], VueLoaderPlugin 让 webpack 认识 vue 123456789 // 使用vue-loader插件const VueLoaderPlugin = require('vue-loader/lib/plugin'); plugins: [ new HtmlWebpackPlugin({ filename: '../index.html', //让生成的文件，往上返一层 template: './src/index.html' }), new CleanWebpackPlugin([\"dist\"]) //自动删除文件 ], 开启热替换1plugins: [new webpack.HotModuleReplacementPlugin()]; CleanWebpackPlugin 自动删除打包文件12345//请求清除文件的插件const CleanWebpackPlugin = require('clean-webpack-plugin');plugins: [ new CleanWebpackPlugin(), //自动删除文件], FriendlyErrorsPlugin 开发环境控制台友好提示插件 npm install friendly-errors-webpack-plugin –save-dev 1234567891011121314151617181920212223242526// 友好的错误提示const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')plugins: [ new FriendlyErrorsPlugin({ compilationSuccessInfo: { messages: [`You application is running here http://${HOST}:${PORT}`], notes: ['Some additionnal notes to be displayed unpon successful compilation'] }, onErrors: function (severity, errors) { console.log(severity, errors); // You can listen to errors transformed and prioritized by the plugin // severity can be 'error' or 'warning' }, // should the console be cleared between each compilation? // default is true clearConsole: true, // add formatters and transformers (see below) additionalFormatters: [], additionalTransformers: [] })],devServer: { // 清理控制台 quiet: true, // necessary for FriendlyErrorsPlugin} 4、loadReact 文件需要 loader 来处理 npm i ，自动安装配置文件里面的插件npm i -S react react-dom,安装这 2 个库 1234\"dependencies\": { \"react\": \"^16.2.0\", \"react-dom\": \"^16.2.0\"} 改写 app.js 文件 123import React from 'react';import ReactDom from 'react-dom';ReactDom.render(&lt;div&gt;Hello React&lt;/div&gt;, document.getElementById('root')); 执行 npm run dev，发现要求先加载 安装 babel loader 库 npm i -D babel-loader babel-core 1234567\"devDependencies\": { \"babel-core\": \"^6.26.0\",//babel核心库 \"babel-loader\": \"^7.1.4\",//babel loader \"html-webpack-plugin\": \"^3.1.0\", \"webpack\": \"^4.2.0\", \"webpack-cli\": \"^2.0.13\"}, 下载 react 预设 npm i -D babel-preset-react 1234567891011121314151617181920212223{ \"name\": \"aaa\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"webpack.config.dev.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack --config webpack.config.dev.js\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.0\", \"babel-loader\": \"^7.1.4\", \"html-webpack-plugin\": \"^3.1.0\", \"webpack\": \"^4.2.0\", \"webpack-cli\": \"^2.0.13\" }, \"dependencies\": { \"react\": \"^16.2.0\", \"react-dom\": \"^16.2.0\" }} 配置 React 预设 123456789101112131415161718192021222324252627const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry: './src/app.js', output: { filename: 'index.js', path: path.resolve(__dirname,'dist/assets') }, mode: 'development', //生成的main。js是生产格式 plugins: [ //plugins后面是数组 new HtmlWebpackPlugin({ filename: 'index.html', template: './src/index.html' }); ], module: { rules:[{ //rules,匹配规则后面加s 后面跟数组，然后对象 test: /\\.js$/, use:[{ //use后面跟数组，然后对象 loader: 'babel-loader', options:{ //options,预设选择规则后面加s presets:['React'] //presets,预设后面加 数组['React'] } }] }] }}; vue-loader 处理 vue 文件12345678{ test: /\\.vue$/, loader: 'vue-loader', exclude: /node_modules/, //排查node_modules options: { extractCSS: true //提交.vue文件中的style作为单个css文件 }} css Loader 安装 css 预处理插件 npm i -D style-loader css-loader 1234567891011\"devDependencies\": { \"babel-core\": \"^6.26.0\", \"babel-loader\": \"^7.1.4\", \"babel-preset-react\": \"^6.24.1\", \"css-loader\": \"^0.28.11\", \"html-webpack-plugin\": \"^3.1.0\", \"style-loader\": \"^0.20.3\", \"webpack\": \"^4.2.0\", \"webpack-cli\": \"^2.0.13\", \"webpack-dev-server\": \"^3.1.1\"} 配置 css Loader 123456789101112131415161718192021module:{ rules:[ { test: /\\.js$/, use: [ { loader: 'babel-loader', options: { presets:[ 'react' ] } } ] }, { //css处理loader test: /\\.css$/, use:['style-loader','css-loader'], //使用默认loader 就不用配置 options } ]}, 图片、字体 file-loader 安装 file-loader npm i -D file-loader 修改 webpack 配置 1234{ test: /\\.jpg$/, use:['file-loader'] //解析图片} 安装 file-loader 增强型 url-loader 设置多种格式图片，file-loader 对图片进行打包npm i -D url-loader 12345678910111213\"devDependencies\": { \"babel-core\": \"^6.26.0\", \"babel-loader\": \"^7.1.4\", \"babel-preset-react\": \"^6.24.1\", \"css-loader\": \"^0.28.11\", \"file-loader\": \"^1.1.11\", \"html-webpack-plugin\": \"^3.1.0\", \"style-loader\": \"^0.20.3\", \"url-loader\": \"^1.0.1\", \"webpack\": \"^4.2.0\", \"webpack-cli\": \"^2.0.13\", \"webpack-dev-server\": \"^3.1.1\"}, 配置 url-load url-load 把图片改变成代码写到页面里面，不对图片进行打包，图片太大的话，就不用 url-load 123456789{ test: /\\.(jpg|gif|png|jpeg)$/, use:[{ loader: \"url-loader\", options: { limit: 200000 //200kb 图片小于 200kbd 的，图片变成 base64 编码的 date url } }]} 配置 _字体_，用 file-loader 1234{ test: /\\.(eot|svg|ttf|woff|woff2|otf)/, use: [\"file-loader\"]} css 模块化 Hello React 这个 CSS 模块化样式添加不了，需要额外设置 webpack 1234567891011121314151617181920212223242526//处理css中出现的url，会自动帮你引入要引入的模块{ test: /\\.css$/, use: [ 'style-loader', { loader: 'css-loader', //配置模块化CSS options: { module: true, //开启css模块化 localIdentName: '[path]-[name]-[local]_[hash:base64:6]' //className名称 } }],exclude: [ //这两个通用文件不要模块化 path.resolve(__dirname,\"node_module\"), path.resolve(__dirname,\"src/common/style\")]},{ test: /\\.css$/, use:['style-loader','css-loader'], include: [ //上面被排除的文件，这里引入 path.resolve(__dirname,\"node_module\"), path.resolve(__dirname,\"src/common/style\") ]} Scss 安装 npm i -D sass-loader node-sass 配置 webpack 与 css 一样开启模块化配置 12345678910111213141516171819202122232425{ test: /\\.scss$/, //test: /\\.scss$/, use: [ 'style-loader', { loader: 'css-loader', options: { module: true } }, \"sass-loader\" //\"sass-loader\" ], exclude: [ path.resolve(__dirname,'node_modules'), path.resolve(__dirname,'src/common/style') ]},{ test: /\\.scss$/, //test: /\\.scss$/, use: ['style-loader',\"css-loader\",\"sass-loader\"], //\"sass-loader\" include: [ path.resolve(__dirname,'node_modules'), path.resolve(__dirname,'src/common/style') ]} Less 文件 npm i -D less-loader less 配置 webpack 开启模块化12345678910111213141516171819202122232425{ test: /\\.less$/, //test: /\\.less$/, use: [ 'style-loader', { loader: 'css-loader', options: { module: true } }, \"less-loader\" // \"less-loader\" ], exclude: [ path.resolve(__dirname,'node_modules'), path.resolve(__dirname,'src/common/style') ]},{ test: /\\.less$/, //test: /\\.less$/, use: ['style-loader',\"css-loader\",\"less-loader\"], // \"less-loader\" include: [ path.resolve(__dirname,'node_modules'), path.resolve(__dirname,'src/common/style') ]} babel 安装 babel npm i -D babel-cli 1234\"devDependencies\": { \"babel-core\": \"^6.26.0\", \"babel-cli\": \"^6.26.0\"} 用 babel 编译 js 文件 ./node_modules/.bin/babel src/index.js 可以简化 babel 编译 js 文件 123456\"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack --config webpack.config.dev.js\", \"start\": \"webpack-dev-server --config webpack.config.dev.js\", \"babel\": \"babel src/index.js\"} npm run babel babel 编译 ES6 件需要插件，不然输入的还是 es6 &gt; npm install --save-dev babel-plugin-transform-es2015-arrow-functions 配置 babel 箭头函数插件, 只解析了箭头函数 123456789\"devDependencies\":{ \"babel-plugin-transform-es2015-arrow-functions\": \"^6.22.0\"},\"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack --config webpack.config.dev.js\", \"start\": \"webpack-dev-server --config webpack.config.dev.js\", \"babel\": \"babel src/index.js --plugins transform-es2015-arrow-functions\"}, 配置 babel 类插件,解析 class npm install –save-dev babel-plugin-transform-es2015-classes 1234567\"devDependencies\": { \"babel-plugin-transform-es2015-arrow-functions\": \"^6.22.0\", \"babel-plugin-transform-es2015-classes\": \"^6.24.1\"},\"scripts\": { \"babel\": \"babel src/in.js --plugins=transform-es2015-arrow-functions,transform-es2015-classes\"}, 安装 babel-preset-env npm install babel-preset-env –save-dev 配置.babelrc 文件 1234{ \"plugins\": [\"transform-es2015-arrow-functions\",\"transform-es2015-classes\"], //删除 \"presets\": [\"env\"]} 重新认识 babel-loader 配置.babelrc 文件 123{ \"presets\": [\"env\",\"react\"]} 修改 webpack 12345678910111213141516171819202122{ test: /\\.js$/, use: [ { loader: 'babel-loader', options: { presets:[ 'react', 'env' //可以解析es6 ] } } ]},{ test: /\\.(js|jsx)$/, loader: 'babel-loader', exclude: /node_modules/, //排查node_modules options: { presets: ['env'] //作为参数传入 babel-loader,babel-loader会根据不同浏览器，自动编译成es5或es6 } } 配置结构赋值扩展 rest-spread npm install –save-dev babel-plugin-transform-object-rest-spread 配置.babelrc 1234{ \"presets\": [\"env\",\"react\"], \"plugins\": [\"transform-object-rest-spread\"]} 配置 webpack 123456789101112131415{ test: /\\.js$/, use: [ { loader: 'babel-loader', options: { presets:[ 'react', 'env' ], \"plugins\": [\"transform-object-rest-spread\"] } } ]}, 优化 babel-loader 引入的 node_modules 文件都不需要 babel 来处理，例如 react 12345678910111213141516{ test: /\\.js$/, use: [ { loader: 'babel-loader', options: { presets:[ 'react', 'env' ], \"plugins\": [\"transform-object-rest-spread\"] } } ], excloude: [path.resolve(__dirname,\"node_modules\")] //排除}, webpack 的 babel-loader 配置会越来越复杂，可以把配置写到.babelrc 中 1234{ \"presets\": [\"env\",\"react\"], \"plugins\": [\"transform-object-rest-spread\"]} 删除 webpack 中的 options{}配置 123456789{ test: /\\.js$/, use: [ { loader: 'babel-loader' } ], exclude: [path.resolve(__dirname,\"node_modules\")]}, 给字体、JS、img 文件归类，修改 webpack 1234567891011{ test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ { loader: 'file-loader', options: { name: '[name]_[hash:8].[ext]' //修改生成字体文件的名称 } } ]} 12345output: { filename: 'js/main.js', //js位置 path: path.resolve(__dirname,'dist/assets'), // publicPath: '/assets/'}, 12345678910{ test: /\\.(jpg|gif|png|jpeg)\\$/, use:[{ loader: \"url-loader\", options: { limit: 200000, name: 'img/[name]\\_[hash:8].[ext]' //img 存储位置 } }]}] 5、配置 devsever 插件 webpack-dev-server 能够用于快速开发应用程序 npm i -D webpack-dev-server 修改配置文件，启动 server，localhost 12345\"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack --config webpack.config.dev.js\", \"start\": \"webpack-dev-server --config webpack.config.dev.js\" //启动server}, 修改 webpack 配置 devServer 自动打开浏览器 12345678910devServer: { //devServer 中S大写 open : true, //自动打开浏览器 port: 9000},plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', //想要浏览器自动打开，文件名要用index.html template: './src/index.html' })], 4.区分生产环境 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 开发环境开启热加载if (process.env.NODE_ENV === 'development') { config.devServer = { contentBase: false, //我这里没有设置contentBase，个人研究contentBase必须指向存在的bundle.js文件所在目录， //因为这里是开发模式，所以dist目录并不存在，所以用false. // publicPath: 'http://www.baidu.com', compress: true, // gzip压缩 allowedHosts: [ 'host.com', 'subdomain.host.com', 'subdomain2.host.com', 'host2.com', ], host: 'localhost', port: '8888', // after: function(app,server) { // console.log(app,server,\"after\") // }, inline: true, //会在构建完变化后的代码时通过代理客户端控制网页刷新。 hot: true, //热部署 progress: true, watchOptions: { aggregateTimeout: 2000, //浏览器延迟多少秒更新 poll: 1000, //每秒检查一次变动 }, compress: true, //一切服务都启用gzip 压缩 historyApiFallback: true, //找不到页面默认跳index.html open: true, //自动打开浏览器 // https: false, // 开启https proxy: [ { context: ['/pcp', '/iam', '/new', '/mpdpc', '/privateAdmin'], target: 'http://dip.cnsuning.com:80/service/2066/1.0.0', changeOrigin: true, }, { context: ['/scam'], // target: 'http://dip.cnsuning.com:80/service/1542767570756/V1.0', target: 'http://yunadminsit.cnsuning.com', changeOrigin: true, }, { context: ['/auth'], target: 'http://yunadminsit.cnsuning.com', changeOrigin: true, }, ], };} 6、资源加载路径出错 配置此 publicPath 12345output: { filename: 'js/main.js', path: path.resolve(__dirname,'dist/assets'), publicPath: 'assets/' //所有资源的公共资源，必须/结尾}, npm run dev 打包没问题 npm start 找不到资源 .babelrc 1234{ \"presets\": [\"env\",\"react\"], \"plugins\": [\"transform-object-rest-spread\"]} 配置 devServer 的 publicPath //所有资源的公共资源，必须/结尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//请求一个path模块const path = require('path');//请求自动创建html插件const HtmlWebpackPlugin = require('html-webpack-plugin');//请求清除文件的插件const CleanWebpackPlugin = require('clean-webpack-plugin');//到出module.exports = { // 入口文件，用绝对路径，保证我们不因为路径发生错误 //path.join(__dirname, 'src/index.js')中__dirname表示当前文件的路径，path.join就是将当前文件的路径跟'src/index.js'拼接起来，形成一个绝对路径 mode: 'development', entry: './src/App.js', output: { filename: 'assets/js/main.js', // 打包后的文件名 path: path.resolve(__dirname, 'dist/'), // 项目的打包文件路径 publicPath: '/', // 通过devServer访问路径 }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: './src/index.html', }), new CleanWebpackPlugin(), ], module: { rules: [ { test: /\\.js$/, use: [ { loader: 'babel-loader', }, ], exclude: [path.resolve(__dirname, 'node_modules')], }, //处理css中出现的url，会自动帮你引入要引入的模块 { test: /\\.css$/, use: [ 'style-loader', { loader: 'css-loader', options: { module: true, localIdentName: '[path]-[name]-[local]_[hash:base64:6]', }, }, ], exclude: [ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'src/common/style'), ], }, { test: /\\.css$/, use: ['style-loader', 'css-loader'], include: [ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'src/common/style'), ], }, { test: /\\.scss$/, use: [ 'style-loader', { loader: 'css-loader', options: { module: true, }, }, 'sass-loader', ], exclude: [ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'src/common/style'), ], }, { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'], include: [ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'src/common/style'), ], }, { test: /\\.less$/, use: [ 'style-loader', { loader: 'css-loader', options: { module: true, }, }, 'less-loader', ], exclude: [ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'src/common/style'), ], }, { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'], include: [ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'src/common/style'), ], }, //file-loader: // 1、把你的资源移动到输入目录 // 2、返回最终引入资源的 url // 3、变成 date url { test: /\\.(jpg|gif|png|jpeg)$/, use: [ { loader: 'url-loader', options: { limit: 200000, name: 'assets/img/[name]_[hash:8].[ext]', // 'assets/img/[name]_[hash:8].[ext]' }, }, ], }, { test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ { loader: 'file-loader', options: { name: 'assets/fonts/[name]_[hash:8].[ext]', //'assets/fonts/[name]_[hash:8].[ext]' }, }, ], }, ], }, devServer: { open: true, port: 9000, publicPath: '/', historyApiFallback: true, overlay: true, },}; wepack 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152const path = require('path');const webpack = require('webpack');// 打包html模板const HtmlWebpackPlugin = require('html-webpack-plugin');// 使用vue-loader插件const VueLoaderPlugin = require('vue-loader/lib/plugin');//请求清除文件的插件const CleanWebpackPlugin = require('clean-webpack-plugin');const config = { mode: 'development', // 入口文件，用绝对路径，保证我们不因为路径发生错误 //path.join(__dirname, 'src/index.js')中__dirname表示当前文件的路径，path.join就是将当前文件的路径跟'src/index.js'拼接起来，形成一个绝对路径 entry: { app: './src/app.js', //入口js }, output: { //打包输出目录 path: path.join(__dirname, '../dist'), //打包输出路径 filename: '[name].[hash].js', //打包输出文件名字 name对应 entry 里面的 app publicPath: '/', // 通过devServer访问路径 }, module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', exclude: /node_modules/, //排查node_modules options: { extractCSS: true, //提交.vue文件中的style作为单个css文件 }, }, { test: /\\.css$/, loader: 'style-loader!css-loader', options: { module: true, //开启css模块化 localIdentName: '[path]-[name]-[local]_[hash:base64:6]', //className名称 }, // exclude: /node_modules/ exclude: [ //这两个通用文件不要模块化 path.resolve(__dirname, 'node_module'), path.resolve(__dirname, 'src/common/style'), ], }, { test: /\\.(js|jsx)$/, loader: 'babel-loader', exclude: /node_modules/, //排查node_modules options: { presets: ['env'], //作为参数传入 babel-loader,babel-loader会根据不同浏览器，自动编译成es5或es6 }, }, { test: /\\.(jpg|gif|png|jpeg)$/, loader: 'url-loader', options: { limit: 8192, //200kb 图片小于 200kbd 的，图片变成 base64 编码的 date url name: 'img/[name]_[hash:8].[ext]', //img 存储位置 }, }, { test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, loader: 'file-loader', options: { limit: 8192, name: '[name]_[hash:8].[ext]', //修改生成字体文件的名称 }, }, ], }, plugins: [ new VueLoaderPlugin(), //让webpack认识vue new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin({ filename: 'index.html', // html文件名 template: 'index.html', // 制定文件模板 inject: true, //是否引用打包好的js }), new CleanWebpackPlugin(), //自动删除文件 ], // 默认NPM包导出的是运行时构建。为了使用独立构建， // 在webpack配置中添加下面的别名 resolve: { // extensions可以免去导入文件的后缀，例如： import vue from ‘vue.js’ 改成 import vue from ‘vue’ // alias可重新配置模块路径，可以省去很长的写法。 extensions: ['.js', '.vue', '.json'], alias: { vue: 'vue/dist/vue.js', //导入node_modules '@': path.resolve(__dirname, './../src'), }, }, devtool: 'cheap-module-eval-source-map', // devServer: { // inline: true, // hot: true, //热部署 // progress: true, // open: true, //自动打开浏览器 // },};// 开发环境开启热加载if (process.env.NODE_ENV === 'development') { config.devServer = { contentBase: false, //我这里没有设置contentBase，个人研究contentBase必须指向存在的bundle.js文件所在目录， //因为这里是开发模式，所以dist目录并不存在，所以用false. // publicPath: 'http://www.baidu.com', compress: true, // gzip压缩 allowedHosts: [ 'host.com', 'subdomain.host.com', 'subdomain2.host.com', 'host2.com', ], host: 'localhost', port: '8888', // after: function(app,server) { // console.log(app,server,\"after\") // }, inline: true, //会在构建完变化后的代码时通过代理客户端控制网页刷新。 hot: true, //热部署 progress: true, watchOptions: { aggregateTimeout: 2000, //浏览器延迟多少秒更新 poll: 1000, //每秒检查一次变动 }, compress: true, //一切服务都启用gzip 压缩 historyApiFallback: true, //找不到页面默认跳index.html open: true, //自动打开浏览器 // https: false, // 开启https proxy: [ { context: ['/pcp', '/iam', '/new', '/mpdpc', '/privateAdmin'], target: 'http://dip.cnsuning.com:80/service/2066/1.0.0', changeOrigin: true, }, { context: ['/scam'], // target: 'http://dip.cnsuning.com:80/service/1542767570756/V1.0', target: 'http://yunadminsit.cnsuning.com', changeOrigin: true, }, { context: ['/auth'], target: 'http://yunadminsit.cnsuning.com', changeOrigin: true, }, ], };}module.exports = config;","link":"/2019/03/29/2019-03-29 了解Webpack/"},{"title":"Vuex的理解","text":"由于Vuex的官方文档在各个模块之间缺乏一些过渡，另外新概念很多，使得初读时总有些云里雾里的感觉。于是本文在官方文档的基础上补充了一些自己的理解及相关的背景知识，尤其是试图让各个部分之间形成一定的连贯关系。希望能帮助初学者更快地理解Vuex。 一、Vuex是干什么用的？它是用于对复杂应用进行状态管理用的（官方说法是它是一种状态管理模式）。 “杀鸡不用宰牛刀”。对于简单的项目，根本用不着Vuex这把“宰牛刀”。那简单的项目用什么呢？用Vue.js官方提供的事件总线就可以了。 二、我们import进来的Vuex对象都包含些什么呢？我们使用Vuex的时候怎么用呢？通常都是这样： 2.1 创建store.js文件 123456789101112131415161718192021222324252627282930313233import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store({ state: { params: { P_START_DATE: \"\", P_END_DATE: \"\", P_CHANNEL_ID: \"\", P_PRODUCT_LINE: \"\", P_ORG_CODE: \"\" } }, getters: { getParams(state){ return state.params; } }, // 同步 mutations: {// 可以通过mutations来改变state值 changeParams(state,payload){// payload 对象方式提交 return state.params = payload.payload; } }, // actions与mutations区别就是，actions异步 actions: {// 也可以通过atctions来调用mutations方法，来改变state changeParams(content,payload){ content.commit(\"changeParams\",payload) } }});export default store; 2.2 在vue入口文件mian.js中注册store 1234567import Vue from 'vue'import store from './store/store.js'new Vue({ el: '#app', store, ...}); 这里import进来的Vuex是个什么东西呢？我们用console.log把它输出一下： 1console.log(Vuex) 通过输出，我们发现其结构如下： 1234567891011{ Store:function Store(options), createNamespacedHelpers:function (namespace), install:function install(_Vue), mapActions:function (namespace, map), // 对应Actions的结果集 mapGetters:function (namespace, map), // 对应Getters的结果集 mapMutations:function (namespace, map), // 对应Mutations的结果集 mapState:function (namespace, map), // 对应State的结果集 version:\"3.0.1\", __proto__:Object,} 可见，import进来的Vuex它实际上是一个对象，里面包含了Store这一构造函数，还有几个mapActions、mapGetters、mapMutations、mapState这几个辅助方法 除此之外，还有一个install方法。我们发现，import之后要对其进行Vue.use(Vuex);的操作。根据这两个线索，我们就明白了，Vuex本质上就是一个Vue.js的插件。不信你去对照下Vue.js的官方文档中对于插件的解释就知道了（见这里）。 三、创建好的store实例怎么在各个组件中都能引用到？new Vuex.Store实例，怎么才能在各个组件中都能引用到呢？因为这个store实例是个全局单例。Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中： 123456const app = new Vue({ el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, ...}) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store访问到。 1console.log(this.$store) 通过输出，我们发现其结构如下： 123456789101112131415161718{ commit:function boundCommit(type, payload, options), dispatch:function boundDispatch(type, payload), getters:Object, // 可以通过getters，获取到store中的全局对象 strict:false, _actionSubscribers:Array(0), _actions:Object, _committing:false, _modules:ModuleCollection, _modulesNamespaceMap:Object, _mutations:Object, _subscribers:Array(0), _vm:Vue, _watcherVM:Vue, _wrappedGetters:Object, state:Object, //可以通过state，获取到store中的全局对象 __proto__:Object,} 四、Vuex中的几大核心概念1、State这个很好理解，就是状态数据。Vuex所管理的就是状态，其它的如Actions、Mutations都是来辅助实现对状态的管理的。Vue组件要有所变化，也是直接受到State的驱动来变化的。 可以通过this.$store.state来直接获取状态，也可以利用vuex提供的mapState辅助函数将state映射到计算属性（computed）中去。 this.$store.state来获取数据，通过mutations，或者actions来改变state值，请看下面介绍12345678// 在单独构建的版本中辅助函数为 Vuex.mapStateexport default { computed:{ params() { return this.$store.state.params } },} 1234567let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.params; mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： mapState通过扩展运算符将store.state.params 映射到子组件的this.params,这个this很重要，这个映射直接映射到当前Vue的this对象上。 12345678910111213141516171819// 在单独构建的版本中辅助函数为 Vuex.mapStateimport { mapState } from 'vuex'export default { computed:{ ...mapState({ // 箭头函数可使代码更简练 // params: state =&gt; state.params, // 传字符串参数 'count' 等同于 `state =&gt; state.count` // params: 'params', // 为了能够使用子组件中的 `this` 获取局部状态，必须使用常规函数 params(state){ return state.params; } }) },} 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 1234567891011// 在单独构建的版本中辅助函数为 Vuex.mapStateimport { mapState } from 'vuex'export default { computed:{ ...mapState([ // 映射 this.params 为 store.state.params 'params' ]) },} mapState通过扩展运算符将store.state.params 映射到子组件的this.params,就可以直接对this.params解构赋值，获取state里面的值1234567let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.params; 2、GettersGetters本质上是用来对状态进行加工处理。Getters与State的关系，就像Vue.js的computed与data的关系。getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 可以通过this.$store.getters对派生出来的状态进行访问。或者直接使用辅助函数mapGetters将其映射到本地计算属性中去。 this.$store.getters来获取数据，通过mutations，或者actions来改变state值，请看下面介绍12345678// 在单独构建的版本中辅助函数为 Vuex.mapStateexport default { computed:{ getParams() { return this.$store.getters.getParams; } },} 1234567let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.getParams; mapGetters 辅助函数如果你想将一个 getter 属性另取一个名字，使用对象形式： 1234567891011import { mapGetters } from 'vuex'export default { computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters({ // 传字符串参数 'params' 等同于 `state =&gt; state.params` getParams: 'getParams', }) }} mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： 12345678910import { mapGetters } from 'vuex'export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'getParams', ]) }} mapGetters通过扩展运算符将store.getters.getParams 映射到子组件的this.getParams,就可以直接对this.getParams解构赋值，获取getters里面的值 1234567let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.getParams; 上面这段代码中，有个写法大家可能会奇怪，就是...mapGetters。这是什么鬼东西呢？ 其中mapGetters实际上是一个方法Vuex对象上的一个方法，这从本文开头打印的那个Vuex对象的内容可以看出来。…这个符号是ES2015的一个新的语法糖，即将mapGetters处理后的内容展开后填入。 3、MutationsMutations的中文意思是“变化”，利用它可以更改状态。事实上，更改 Vuex 的 store 中的状态的唯一方法就是提交 （commit）mutation。不过，mutation触发状态改变的方式有一点特别，所谓commit一个mutation，实际是像触发一个事件一样，传入一个mutation的类型以及携带一些数据（称作payload，载荷）。 本文开头那段代码中所指明的mutations，即： 1.提交荷载 Payload 123456// 同步mutations: {// 可以通过mutations来改变state值 changeParams(state,payload){ return state.params = payload; }}, 其中所包含的，实际上是一个个的mutation处理函数，用于指明收到这个mutation的commit之后，应该做些什么（当然，主要就是改变state，只是改变哪些state值的问题）。 那commit一个mutation在代码层面怎么表示呢？ 12// mutations// this.$store.commit('changeParams', retailer) 2、对象风格的提交方式 payload.payload 123456// 同步mutations: {// 可以通过mutations来改变state值 changeParams(state,payload){ return state.params = payload.payload; }}, 在子组件中 commit 对象的两种方式 1234this.$store.commit({ type: 'changeParams', payload:retailer}) 123this.$store.commit('changeParams',{ payload: retailer}) 除了这种使用 this.$store.commit('xxx') 提交 mutation的方式之外，还有一种方式，即使用 mapMutations 辅助函数将组件中的 methods 映射为 this.$store.commit。例如： 3、mapMutations mapMutations 提交荷载 Payload 注意：下面代码中，payload 赋值不同 123456// 同步mutations: {// 可以通过mutations来改变state值 changeParams(state,payload){ return state.params = payload; }}, 在父组件中调用，导入mapMutations 1234567891011121314import { mapMutations } from 'vuex'export default { // ... methods: { ...mapMutations([ 'changeParams', // 将 `this.changeParams()` 映射为 `this.$store.commit('changeParams')` ]), ...mapMutations({ changeParams: 'changeParams' // 将 `this.add()` 映射为 `this.$store.commit('changeParams')` }) }} 在方法中调用,retailer:父组件中定义的对象 12345methods: { storeChange() {// 这个方式传参， 让上面的 state = payload this.changeParams(retailer);//有参数 }} 像上面这样，就既声明了收到mutation后怎么处理，又清楚了怎么触发一个mutation。是不是特别像事件的处理函数（handler）以及事件的触发（emit）之间的关系？ 考虑到触发的mutation的type必须与mutations里声明的mutation名称一致，比较好的方式是把这些mutation都集中到一个文件（如mutation-types）中以常量的形式定义，在其它地方再将这个文件引入，便于管理。而且这样做还有一个好处，就是整个应用中一共有哪些mutation type可以一目了然。就像下面这样： 12345678910111213141516// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import { SOME_MUTATION } from './mutation-types'const store = new Vuex.Store({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } }}) 值得注意的是，mutation必须是同步函数，目的是为了在dev-tools中能够捕捉到每一条mutation前后状态的快照（参见https://www.zhihu.com/question/48759748）。 4、Actions与同步函数Mutation所不同，Action可以包含异步的操作。 1、以载荷形式分发(payload) 1234567891011121314151617181920212223242526272829303132import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store({ state: { params: { P_START_DATE: \"\", P_END_DATE: \"\", P_CHANNEL_ID: \"\", P_PRODUCT_LINE: \"\", P_ORG_CODE: \"\" } }, getters: { getParams(state){ return state.params; } }, // 同步 mutations: { changeParams(state,payload){ return state.params = payload; }, }, // actions与mutations区别就是，actions异步 actions: { changeParams(content,payload){ content.commit(\"changeParams\",payload) } }});export default store; 或者用ES2015的参数解构，可以简写成： 123456// actions与mutations区别就是，actions异步actions: { changeParams({commit},payload){ commit(\"changeParams\",payload) }} 和mutation类似，我们像上面这样生命action的处理函数。它接收的第一个参数是一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 不过，mutation处理函数中所做的事情是改变state，而action处理函数中所做的事情则是commit mutation。 那么，怎么触发action呢？按照Vuex的叫法，这叫分发（dispatch），我觉得这个名字让人不好理解，我们反正知道它实际上是触发的意思就行了。具体的触发方法是this.$store.dispatch(actionType, payload)。所传的两个参数一个是要触发的action的类型，一个是所携带的数据（payload），类似于上文所讲的commit mutation时所传的那两个参数。具体如下： 123// 以载荷形式分发// actionsthis.$store.dispatch('changeParams',retailer); 2、以对象形式分发(payload.payload) 1234567891011121314151617181920212223242526272829303132import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store({ state: { params: { P_START_DATE: \"\", P_END_DATE: \"\", P_CHANNEL_ID: \"\", P_PRODUCT_LINE: \"\", P_ORG_CODE: \"\" } }, getters: { getParams(state){ return state.params; } }, // 同步 mutations: { changeParams(state,payload){ return state.params = payload; }, }, // actions与mutations区别就是，actions异步 actions: { changeParams(content,payload){ content.commit(\"changeParams\",payload.payload) } }});export default store; 12345678910// 以对象形式分发this.$store.dispatch('changeParams', { payload:retailer})// 以对象形式分发this.$store.dispatch({ type: 'changeParams', payload:retailer}) 还有一种方法是使用 mapActions 辅助函数将组件的 methods 映射为 this.$store.dispatch 调用。如下： 3、 mapActions 12345678910111213141516import { mapActions } from 'vuex'export default { // ... methods: { ...mapActions([ 'changeParams', // 将 `this.changeParams()` 映射为 `this.$store.dispatch('changeParams')` // `mapActions` 也支持载荷： 'changeParams' // 将 `this.changeParams(amount)` 映射为 `this.$store.dispatch('changeParams', amount)` ]), ...mapActions({ add: 'changeParams' // 将 `this.add()` 映射为 `this.$store.dispatch('changeParams')` }) }} 12this.changeParams(retailer)this.add(retailer) 另外，你需要知道， this.$store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 this.$store.dispatch 仍旧返回 Promise。 再来看一些组合性的异步操作： 12345678910actions: { actionA ({ commit }) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { commit('changeParams') resolve() }, 1000) }) }} 现在你可以： 123$this.store.dispatch('actionA').then(() =&gt; { // ...}) 在另外一个 action 中也可以： 12345678actions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() =&gt; { commit('someOtherMutation') }) }} 最后，如果我们利用 async / await 这个 JavaScript 即将到来的新特性，我们可以像这样组合 action： 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: { async actionA ({ commit }) { commit('gotData', await getData()) }, async actionB ({ dispatch, commit }) { await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) }} 这实际上就实现了action嵌套另一个action的情况。 讲了这么多action，你可能会纳闷一个问题：action这鬼东西不是和mutation看起来好多地方都很像吗，直接触发mutation去改变state岂不更好？为什么还要先触发action，再由action去触发mutation才达到改变state的目的？ 这是个好问题。还记得上面我们提到过mutation只能是同步的操作而action可以是包含异步操作吗？那么，若想进行异步操作，通过mutation显然是无法完成的，所以就有了action。我们来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation： 12345678910111213141516actions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =&gt; commit(types.CHECKOUT_SUCCESS), // 失败操作 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) }} 5、ModuleModule是什么概念呢？它实际上是对于store的一种切割。由于Vuex使用的是单一状态树，这样整个应用的所有状态都会集中到一个比较大的对象上面，那么，当应用变得非常复杂时，store 对象就很可能变得相当臃肿！ 为了解决以上问题，Vuex 允许我们将 store 分割成一个个的模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。就像这样： 12345678910111213141516171819202122const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... }}const moduleB = { state: { ... }, mutations: { ... }, actions: { ... }}const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB }})store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 1、模块的局部状态对于每个模块内部的 mutation 和 getter，接收的第一个参数就是模块的局部状态对象。 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：对于模块内部的 getter，根节点状态会作为第三个参数暴露出来： 123456789101112131415161718192021222324252627282930313233343536373839import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const retailer = { namespaced: true, state: { params: { P_START_DATE: \"20181011\", P_END_DATE: \"20181201\", P_CHANNEL_ID: \"\", P_PRODUCT_LINE: \"\", P_ORG_CODE: \"\" } }, getters: { getParams(state, getters, rootState){ return state.params; } }, // 同步 mutations: { changeParams(state,payload){ return state.params = payload; }, }, // actions与mutations区别就是，actions异步 actions: { changeParams({ state, commit, rootState },payload){ commit(\"changeParams\",payload) } }}const store = new Vuex.Store({ modules: { retailer: retailer }});export default store; 在IocRetailerParent.vue文件中，调取mutation、actions 123this.$store.commit('retailer/changeParams', retailer);this.$store.dispatch('retailer/changeParams', retailer); 在IocRetailerFirst.vue文件中，获取参数1234567891011121314151617&lt;!-- state --&gt;let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.$store.state.retailer.params;&lt;!-- getters --&gt;let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.$store.getters[\"retailer/getParams\"]; 2、mapState 在IocRetailerFirst.vue文件中，获取参数 1234567891011121314computed: { ...mapState('retailer',{ params: state =&gt; state.params });}let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.params; 3、mapGetters 在IocRetailerFirst.vue文件中，获取参数 123456789101112131415computed: { ...mapGetters('retailer',{ // 传字符串参数 'params' 等同于 `state =&gt; state.params` getParams: 'getParams', })}let { P_START_DATE, P_END_DATE, P_CHANNEL_ID, P_PRODUCT_LINE, P_ORG_CODE} = this.getParams; 4、mapMutations 在IocRetailerFirst.vue文件中，获取参数 1234567891011121314methods: { ...mapMutations('retailer',{ // 传字符串参数 'params' 等同于 `state =&gt; state.params` changeParams: 'changeParams', }), ...mapMutations('retailer',[ 'changeParams' // 将 `this.add()` 映射为 `this.$store.commit('changeParams')` ]), &lt;!-- 调用mapMutations方法 --&gt; storeChange(retailer) { this.changeParams(retailer); }} 5、mapActions 在IocRetailerFirst.vue文件中，获取参数 1234567891011121314methods: { ...mapActions('retailer',{ // 传字符串参数 'params' 等同于 `state =&gt; state.params` changeParams: 'changeParams', }), ...mapActions('retailer',[ 'changeParams' // 将 `this.add()` 映射为 `this.$store.commit('changeParams')` ]), &lt;!-- 调用mapMutations方法 --&gt; storeChange(retailer) { this.changeParams(retailer); }} 命名空间默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如： 12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store({ modules: { account: { namespaced: true, // 模块内容（module assets） state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: { isAdmin () { ... } // -&gt; getters['account/isAdmin'] }, actions: { login () { ... } // -&gt; dispatch('account/login') }, mutations: { login () { ... } // -&gt; commit('account/login') }, // 嵌套模块 modules: { // 继承父模块的命名空间 myPage: { state: { ... }, getters: { profile () { ... } // -&gt; getters['account/profile'] } }, // 进一步嵌套命名空间 posts: { namespaced: true, state: { ... }, getters: { popular () { ... } // -&gt; getters['account/posts/popular'] } } } } }}) 启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。 在命名空间模块内访问全局内容（Global Assets）如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit即可。 12345678910111213141516171819202122232425262728293031modules: { foo: { namespaced: true, getters: { // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) { getters.someOtherGetter // -&gt; 'foo/someOtherGetter' rootGetters.someOtherGetter // -&gt; 'someOtherGetter' }, someOtherGetter: state =&gt; { ... } }, actions: { // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction ({ dispatch, commit, getters, rootGetters }) { getters.someGetter // -&gt; 'foo/someGetter' rootGetters.someGetter // -&gt; 'someGetter' dispatch('someOtherAction') // -&gt; 'foo/someOtherAction' dispatch('someOtherAction', null, { root: true }) // -&gt; 'someOtherAction' commit('someMutation') // -&gt; 'foo/someMutation' commit('someMutation', null, { root: true }) // -&gt; 'someMutation' }, someOtherAction (ctx, payload) { ... } } }} 带命名空间的绑定函数当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定命名空间模块时，写起来可能比较繁琐： 123456789101112computed: { ...mapState({ a: state =&gt; state.some.nested.module.a, b: state =&gt; state.some.nested.module.b })},methods: { ...mapActions([ 'some/nested/module/foo', 'some/nested/module/bar' ])} 对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为： 123456789101112computed: { ...mapState('some/nested/module', { a: state =&gt; state.a, b: state =&gt; state.b })},methods: { ...mapActions('some/nested/module', [ 'foo', 'bar' ])} 而且，你可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数： 1234567891011121314151617181920import { createNamespacedHelpers } from 'vuex'const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')export default { computed: { // 在 `some/nested/module` 中查找 ...mapState({ a: state =&gt; state.a, b: state =&gt; state.b }) }, methods: { // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) }} 给插件开发者的注意事项如果你开发的插件（Plugin）提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称： 123456789// 通过插件的参数对象得到空间名称// 然后返回 Vuex 插件函数export function createPlugin (options = {}) { return function (store) { // 把空间名字添加到插件模块的类型（type）中去 const namespace = options.namespace || '' store.dispatch(namespace + 'pluginAction') }} 模块动态注册在 store 创建之后，你可以使用 store.registerModule 方法注册模块： 12345678// 注册模块 `myModule`store.registerModule('myModule', { // ...})// 注册嵌套模块 `nested/myModule`store.registerModule(['nested', 'myModule'], { // ...}) 之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。 模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。 你也可以使用 store.unregisterModule(moduleName) 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。 模块重用有时我们可能需要创建一个模块的多个实例，例如： 创建多个 store，他们公用同一个模块 在一个 store 中多次注册同一个模块 如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。 实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）： 12345678const MyReusableModule = { state () { return { foo: 'bar' } }, // mutation, action 和 getter 等等...} 六、严格模式Vuex的严格模式，是指其在开启严格模式的情况下，只要发现某个状态变更不是由 mutation 函数引起的，都将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 开启严格模式，仅需在创建 store 的时候传入 strict: true： 1234const store = new Vuex.Store({ // ... strict: true}) 注意： 不要在发布环境下启用严格模式，以避免性能损失！严格模式会深度监测状态树来检测不合规的状态变更。 类似于插件，我们可以让构建工具来处理这种情况： 1234const store = new Vuex.Store({ // ... strict: process.env.NODE_ENV !== 'production'}) 七、双向绑定的处理当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会比较棘手： 1&lt;input v-model=\"obj.message\"&gt; 假设这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。 用“Vuex 的思维”去解决这个问题的方法是：给 &lt;input&gt; 中绑定 value，然后侦听 input 或者 change 事件，在事件回调中调用 action: 1&lt;input :value=\"message\" @input=\"updateMessage\"&gt; 1234567891011// ...computed: { ...mapState({ message: state =&gt; state.obj.message })},methods: { updateMessage (e) { this.$store.commit('updateMessage', e.target.value) }} 下面是 mutation 函数： 123456// ...mutations: { updateMessage (state, message) { state.obj.message = message }} 双向绑定的计算属性必须承认，这样做比简单地使用“v-model + 局部状态”要啰嗦得多，并且也损失了一些 v-model 中很有用的特性。另一个方法是使用带有 setter 的双向绑定计算属性： 12345678910111213&lt;input v-model=\"message\"&gt;// ...computed: { message: { get () { return this.$store.state.obj.message }, set (value) { this.$store.commit('updateMessage', value) } }} 八、热重载使用 webpack 的 Hot Module Replacement API，Vuex 支持在开发过程中热重载 mutation、module、action 和 getter。你也可以在 Browserify 中使用 browserify-hmr 插件。 对于 mutation 和模块，你需要使用 store.hotUpdate() 方法： 例子（来自https://github.com/vuejs/vuex/blob/dev/examples/counter-hot/store/index.js）： 1234567891011121314151617181920212223242526272829303132333435import Vue from 'vue'import Vuex from 'vuex'import * as getters from './getters'import * as actions from './actions'import * as mutations from './mutations'Vue.use(Vuex)const state = { count: 0, history: []}const store = new Vuex.Store({ state, getters, actions, mutations})if (module.hot) { module.hot.accept([ './getters', './actions', './mutations' ], () =&gt; { store.hotUpdate({ getters: require('./getters'), actions: require('./actions'), mutations: require('./mutations') }) })}export default store 主要是下面这一小段代码： 12345678910111213if (module.hot) { module.hot.accept([ './getters', './actions', './mutations' ], () =&gt; { store.hotUpdate({ getters: require('./getters'), actions: require('./actions'), mutations: require('./mutations') }) })} 九、实际使用时的文件结构和关系来看一个Vuex综合运用的例子： 来自：https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart //入口文件：app.js 12345678910111213import 'babel-polyfill'import Vue from 'vue'import App from './components/App.vue'import store from './store'import { currency } from './currency'Vue.filter('currency', currency)new Vue({ el: '#app', store, render: h =&gt; h(App)}) //store/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import cart from './modules/cart'import products from './modules/products'import createLogger from '../../../src/plugins/logger'Vue.use(Vuex)const debug = process.env.NODE_ENV !== 'production'export default new Vuex.Store({ actions, getters, modules: { cart, products }, strict: debug, plugins: debug ? [createLogger()] : []})if (module.hot) { module.hot.accept([ './actions', './getters', './modules/cart', './modules/products' ], () =&gt; { store.hotUpdate({ actions: require('./actions'), getters: require('./getters'), modules: { cart: require('./modules/cart'), products: require('./modules/products') }, mutations: require('./mutations') }) })} //store/mutation-types.js 12345export const ADD_TO_CART = 'ADD_TO_CART'export const CHECKOUT_REQUEST = 'CHECKOUT_REQUEST'export const CHECKOUT_SUCCESS = 'CHECKOUT_SUCCESS'export const CHECKOUT_FAILURE = 'CHECKOUT_FAILURE'export const RECEIVE_PRODUCTS = 'RECEIVE_PRODUCTS' //store/getters.js 12345678910export const cartProducts = state =&gt; { return state.cart.added.map(({ id, quantity }) =&gt; { const product = state.products.all.find(p =&gt; p.id === id) return { title: product.title, price: product.price, quantity } })} //store/actions.js 123456789import * as types from './mutation-types'export const addToCart = ({ commit }, product) =&gt; { if (product.inventory &gt; 0) { commit(types.ADD_TO_CART, { id: product.id }) }} //store/modules/cart.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import shop from '../../api/shop'import * as types from '../mutation-types'// initial state// shape: [{ id, quantity }]const state = { added: [], checkoutStatus: null}// gettersconst getters = { checkoutStatus: state =&gt; state.checkoutStatus}// actionsconst actions = { checkout ({ commit, state }, products) { const savedCartItems = [...state.added] commit(types.CHECKOUT_REQUEST) shop.buyProducts( products, () =&gt; commit(types.CHECKOUT_SUCCESS), () =&gt; commit(types.CHECKOUT_FAILURE, { savedCartItems }) ) }}// mutationsconst mutations = { [types.ADD_TO_CART] (state, { id }) { state.lastCheckout = null const record = state.added.find(p =&gt; p.id === id) if (!record) { state.added.push({ id, quantity: 1 }) } else { record.quantity++ } }, [types.CHECKOUT_REQUEST] (state) { // clear cart state.added = [] state.checkoutStatus = null }, [types.CHECKOUT_SUCCESS] (state) { state.checkoutStatus = 'successful' }, [types.CHECKOUT_FAILURE] (state, { savedCartItems }) { // rollback to the cart saved before sending the request state.added = savedCartItems state.checkoutStatus = 'failed' }}export default { state, getters, actions, mutations} //store/modules/products.js 123456789101112131415161718192021222324252627282930313233343536373839import shop from '../../api/shop'import * as types from '../mutation-types'// initial stateconst state = { all: []}// gettersconst getters = { allProducts: state =&gt; state.all}// actionsconst actions = { getAllProducts ({ commit }) { shop.getProducts(products =&gt; { commit(types.RECEIVE_PRODUCTS, { products }) }) }}// mutationsconst mutations = { [types.RECEIVE_PRODUCTS] (state, { products }) { state.all = products }, [types.ADD_TO_CART] (state, { id }) { state.all.find(p =&gt; p.id === id).inventory-- }}export default { state, getters, actions, mutations} //components/App.vue 123456789101112131415161718&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;Shopping Cart Example&lt;/h1&gt; &lt;hr&gt; &lt;h2&gt;Products&lt;/h2&gt; &lt;product-list&gt;&lt;/product-list&gt; &lt;hr&gt; &lt;cart&gt;&lt;/cart&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProductList from './ProductList.vue'import Cart from './Cart.vue'export default { components: { ProductList, Cart }}&lt;/script&gt; //components/Cart.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=\"cart\"&gt; &lt;h2&gt;Your Cart&lt;/h2&gt; &lt;p v-show=\"!products.length\"&gt;&lt;i&gt;Please add some products to cart.&lt;/i&gt;&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"p in products\"&gt; {{ p.title }} - {{ p.price | currency }} x {{ p.quantity }} &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Total: {{ total | currency }}&lt;/p&gt; &lt;p&gt;&lt;button :disabled=\"!products.length\" @click=\"checkout(products)\"&gt;Checkout&lt;/button&gt;&lt;/p&gt; &lt;p v-show=\"checkoutStatus\"&gt;Checkout {{ checkoutStatus }}.&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapGetters } from 'vuex'export default { computed: { ...mapGetters({ products: 'cartProducts', checkoutStatus: 'checkoutStatus' }), total () { return this.products.reduce((total, p) =&gt; { return total + p.price * p.quantity }, 0) } }, methods: { checkout (products) { this.$store.dispatch('checkout', products) } }}&lt;/script&gt; //components/ProductList.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;ul&gt; &lt;li v-for=\"p in products\"&gt; {{ p.title }} - {{ p.price | currency }} &lt;br&gt; &lt;button :disabled=\"!p.inventory\" @click=\"addToCart(p)\"&gt; Add to cart &lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import { mapGetters, mapActions } from 'vuex'export default { computed: mapGetters({ products: 'allProducts' }), methods: mapActions([ 'addToCart' ]), created () { this.$store.dispatch('getAllProducts') }}&lt;/script&gt; 十、总结1、应用层级的状态应该集中到单个 store 对象中，状态对象太复杂的时候可以划分module。 2、提交 mutation 是更改状态的唯一方法。 3、在触发方法上： action的触发是dispatch mutation的触发是commit； 4、在功能上： state保存的是数据 getters是对state进行二次加工 action的处理函数的功能最终是commit mutation mutation处理函数的功能最终是改变state 5、在同步异步上： 异步逻辑都应该封装到 action 里面 mutation 是同步的，不能出现异步 6、在流程上： vue component—-dispatch—-&gt;actions—-commit—-&gt;mutations—-mutate—-&gt;state—-render—-&gt;vue component。从而形成闭环。见图： 7、辅助方法的映射上： mapGetters、mapState 都是用在computed声明里面； mapActions、mapMutations则都是用在methods声明里面。 参考： https://vuex.vuejs.org/zh-cn/intro.html","link":"/2018/12/01/2018-12-01 Vuex的理解/"},{"title":"React最佳入门","text":"React 是一个用于构建用户界面的 JAVASCRIPT 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React最佳入门 1.运行Hello React 2.认识jsx 3.jsx使用方式 4.认识组件 5.认识props 6.children和类组件的props 7.defaultProps 8.prop-types 9.内部状态state 10.state其它特性 11.事件系统 12.事件系统中this指向 13.生命周期 14.生命周期卸载与其他事项 15.生命周期错误捕获与总结 16.获取真实DOM 17.组件受控 18.基于回调的组件交流 React最佳入门 1.运行Hello React 1.1 全局安装React脚手架： 1234npm install -g create-react-app create-react-app my-app cd my-app npm start 1.2 删除项目src下的所有文件，重新创建 整个项目的入口文件 index.js,编写代码，浏览器即使更新 12345678import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//把你写的结构，通过js渲染到页面上//下面的html，是jsx语法，本质上也是js代码ReactDOM.render( &lt;div&gt;Hello World!&lt;/div&gt;, document.getElementById('root')); 2.认识jsx 每次打开React项目可以先运行 npm i, 安装package.json所需要的插件 安装完成后，项目中会多一个node_modules文件 2.1 npm i 2.2 我们可以用babel工具来转换jsx代码，可以看出jsx语法，被转换成了标准的js语法；而且通过React.createElement()方式创建，所以我们需要引入 1import React from 'react';//引入react用来写jsx语法` 2.3 我看可以看出jsx生成的格式，通过React创建节点，ReactDOM再来插入节点jsx其实就是写结构的语法糖，它会被babel这个工具转变成 js 代码，这个js代码运行后会得到一个对象 这个对象就是virtual DOM 3.jsx使用方式 3.1 jsx中使用表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React,{Fragment} from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//把你写的结构，通过js渲染到页面上//下面的html，是jsx语法，本质上也是js代码let jsx3 = (&lt;Fragment&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/Fragment&gt;);ReactDOM.render( &lt;div&gt; {/*变量直接拼接hello world*/} {s1+' '+s2} {/*模板字符串拼接 hello world*/} {`${s1} ${s2}`} {/*15*/} {6+9} {/*3*/} &lt;p&gt;{sum(1,2)}&lt;/p&gt; {/*如果前面值成立，返回jeo*/} &lt;p&gt;{'hj' &amp;&amp; 'jeo'}&lt;/p&gt; **{/*只能写表达式，不可以写if for等语句，可以写三目运算*/}** {/*嵌入变量*/} {jsx1} {jsx2} {/*嵌入变量,必须有一个闭合标签包含可以用div*/} {jsx3} {/*如果是li,可以用Fragment，来包含,这样就不会多div标签*/} &lt;ul&gt;{jsx3}&lt;/ul&gt; &lt;/div&gt;, document.getElementById('root')); 3.3 jsx 中的闭合 12345678 ReactDOM.render( &lt;div&gt; {/*标签闭合*/} &lt;div /&gt; &lt;/div&gt;, document.getElementById('root')); 3.4 样式也可以采用 import ‘./css’ 1234567 ReactDOM.render( &lt;div&gt; {/*标签闭合*/} &lt;p style={{color:'red',marginLeft:50}}&gt;&lt;/p&gt; &lt;/div&gt;, document.getElementById('root')); 3.5 属性:关键字属性 className“-“ 相邻的，采用驼峰写法 1234567 ReactDOM.render( &lt;div&gt; {/*标签闭合*/} &lt;p className='kkk' style={{color:'red',marginLeft:50}}&gt;&lt;/p&gt; &lt;/div&gt;, document.getElementById('root')); 4.认识组件 4.1 函数组件与类组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//1.组件的表现形式// 函数组件// 类组件//2.使用组件// 标签名大写开头// 变量在作用域内// 小写开头的是dom组件`&lt;vv&gt;ds&lt;/vv&gt;`//3.组件相互嵌套//函数组件function People(){ return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是people&lt;/h2&gt; &lt;/div&gt; )}//类组件class Man extends React.Component{ render(){ return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; {/*组件相互嵌套*/} &lt;People /&gt; &lt;/div&gt; ) }}ReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People /&gt; &lt;People /&gt; &lt;Man /&gt; &lt;/div&gt;, document.getElementById('root')); 4.2 函数组件与类组件分别写入不同的文件中 创建People.js组件 123456789import React from 'react';//函数组件export default function People(){ return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是people&lt;/h2&gt; &lt;/div&gt; )} 创建Man.js组件 1234567891011121314import React,{Component} from 'react';import People from './People.js';//引入people组件//类组件export default class Man extends React.Component{ render(){ return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; &lt;People /&gt; &lt;/div&gt; ) }} 修改index.js入口文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 import React from 'react';//引入react用来写jsx语法 import ReactDOM from 'react-dom'; //1.组件的表现形式 // 函数组件 // 类组件 //2.使用组件 // 标签名大写开头 // 变量在作用域内 // 小写开头的是dom组件`&lt;vv&gt;ds&lt;/vv&gt;` //3.组件相互嵌套 import People from './People.js'; import Man from './Man.js'; ReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People /&gt; &lt;People /&gt; &lt;Man /&gt; &lt;/div&gt;, document.getElementById('root') ); ``` ## 5. 认识props- 创建People.js组件 ```javascriptimport React from 'react';//函数组件export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;h2&gt;我的年龄:{props.age}&lt;/h2&gt; &lt;h2&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/h2&gt; &lt;/div&gt; )} ``` - 创建Man.js组件```javascriptimport React,{Component} from 'react';import People from './People.js';//引入people组件//类组件export default class Man extends React.Component{ render(){ return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; &lt;People /&gt; &lt;/div&gt; ) }} 修改index.js入口文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//1.组件的表现形式// 函数组件// 类组件//2.使用组件// 标签名大写开头// 变量在作用域内// 小写开头的是dom组件`&lt;vv&gt;ds&lt;/vv&gt;`//3.组件相互嵌套import People from './People.js';import Man from './Man.js';//在自定义属性里面，可以直接写一些属性，然后接上一些值//在函数组件中，通过第一个参数来接受propsReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt/&gt; &lt;People /&gt; &lt;Man /&gt; &lt;/div&gt;, document.getElementById('root'));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/props.png\"/&gt; &lt;/div&gt;## 6.children和类组件的props- 创建People.js组件 ```javascriptimport React from 'react';//函数组件export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;h2&gt;我的年龄:{props.age}&lt;/h2&gt; &lt;h2&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/h2&gt; &lt;div&gt;{props.children}&lt;/div&gt; &lt;/div&gt; )} 创建Man.js组件 1234567891011121314151617181920import React,{Component} from 'react';import People from './People.js';//引入people组件//类组件export default class Man extends React.Component{ render(){ /*console.log(this.props)*/ /*在类组件里面，通过组件实例下面的props:this.props*/ let {eyes,hand,peopleName,children} = this.props; return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; &lt;h2&gt;我有{hand}只手&lt;/h2&gt; &lt;h2&gt;我有{eyes}只眼&lt;/h2&gt; &lt;People name={peopleName} age={122} /&gt; {children} &lt;/div&gt; ) }} 修改index.js入口文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';import People from './People.js';import Man from './Man.js';//类组件与函数组件区别//1.接受props不同//2.类组件有实例 this，函数组件没有实例//在自定义属性里面，可以直接写一些属性，然后接上一些值//在函数组件中，通过第一个参数来接受props//在类组件里面，通过组件实例下面的props:this.props//数组是从父组件传给子组件 props//children//组件标签之间的内容就是childrenReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt children={&lt;div&gt;我是people下的children，我从index来&lt;/div&gt;}&gt; {/*children*/} 1234 &lt;/People&gt; &lt;Man eyes={1000} hand={100} peopleName=\"flower\"&gt; 我是index传来的children &lt;/Man&gt; &lt;/div&gt;, document.getElementById('root'));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/propschildren.png\"/&gt; &lt;/div&gt; ## 7.defaultProps - 创建People.js组件 ```javascriptimport React from 'react';//函数组件export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;h2&gt;我的年龄:{props.age}&lt;/h2&gt; &lt;h2&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/h2&gt; &lt;div&gt;{props.children}&lt;/div&gt; &lt;/div&gt; )} 创建Man.js组件 123456789101112131415161718192021222324252627import React from 'react';//函数组件export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;p&gt;我的年龄:{props.age}&lt;/p&gt; &lt;p&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/p&gt; &lt;div&gt;{props.children}&lt;/div&gt; {/*直接获取父组件传来的函数会报错,因为在其他people组件的，并没有传函数；TypeError: props.renderProps is not a function*/} {props.renderProps()} &lt;/div&gt; )}//只有在undefined情况下，获取默认值People.defaultProps={ name:'----------', age:'11111111111', /*可以给它一个默认属性，就不或报错*/ renderProps:()=&gt;{}} 修改index.js入口文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';import People from './People.js';import Man from './Man.js';//defaultProps//给参数设置默认值//：不然给子组件传递函数方法时，如果有多个子组件，没有全部传递函数方法，会报错 如下：renderProps={()=&gt;Math.random()}ReactDOM.render( &lt;div&gt; &lt;People renderProps={()=&gt;Math.random()}/&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt children={&lt;div&gt;我是people下的children，我从index来&lt;/div&gt;}&gt; {/*children*/} 1234 &lt;/People&gt; &lt;Man eyes={1000} hand={100} peopleName=\"flower\"&gt; 我是index传来的children &lt;/Man&gt; &lt;/div&gt;, document.getElementById('root'));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/defaultPROPS.png\"/&gt; &lt;/div&gt; ## 8.prop-types &gt; 安装：`npm install --save prop-types` - 创建People.js组件 ```javascript import React from 'react';import PT from 'prop-types'//函数组件export default function People(props){ console.log(props); return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;p&gt;我的年龄:{props.age}&lt;/p&gt; &lt;p&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/p&gt; &lt;div&gt;{props.children}&lt;/div&gt; {/*直接获取父组件传来的函数会报错,因为在其他people组件的，并没有传函数；TypeError: props.renderProps is not a function*/} {props.renderProps()} &lt;/div&gt; )}//只有在undefined情况下，获取默认值People.defaultProps={ name:'----------', age:'11111111111', /*可以给它一个默认属性，就不或报错*/ renderProps:()=&gt;{}}//数据类型验证People.propTypes={ name:PT.string, age:PT.number, renderProps:PT.func} 创建Man.js组件 123456789101112131415161718192021222324252627import React from 'react';//函数组件export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;p&gt;我的年龄:{props.age}&lt;/p&gt; &lt;p&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/p&gt; &lt;div&gt;{props.children}&lt;/div&gt; {/*直接获取父组件传来的函数会报错,因为在其他people组件的，并没有传函数；TypeError: props.renderProps is not a function*/} {props.renderProps()} &lt;/div&gt; )}//只有在undefined情况下，获取默认值People.defaultProps={ name:'----------', age:'11111111111', /*可以给它一个默认属性，就不或报错*/ renderProps:()=&gt;{}} 修改index.js入口文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155 import React from 'react';//引入react用来写jsx语法 import ReactDOM from 'react-dom'; import People from './People.js'; import Man from './Man.js'; //defaultProps //给参数设置默认值 //：不然给子组件传递函数方法时，如果有多个子组件，没有全部传递函数方法，会报错 如下：renderProps={()=&gt;Math.random()} ReactDOM.render( &lt;div&gt; &lt;People renderProps={()=&gt;Math.random()}/&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt children={&lt;div&gt;我是people下的children，我从index来&lt;/div&gt;}&gt; {/*children*/} 1234 &lt;/People&gt; &lt;Man eyes={1000} hand={100} peopleName=\"flower\"&gt; 我是index传来的children &lt;/Man&gt; &lt;/div&gt;, document.getElementById('root') ); ``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/proptypes.png\"/&gt; &lt;/div&gt;## 9.内部状态state&gt;函数组件没有内部状态，只有类组件有内部状态- state、setState```javascriptimport React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//函数组件没有内部状态，只有类组件有内部状态////setState//改变state值//render方法再次执行，生成新的virtural DOM结构//比较新旧virtual DOM的结构，对变化部分进行更新class MagicNumber extends Component { constructor() { super(); this.state = { number:Math.random(), name:'joe' }; } render() { console.log(this.state); let {number,name} = this.state; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={()=&gt;{this.setState({number : Math.random()})}}&gt;change number&lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber /&gt; &lt;/div&gt;, document.getElementById(\"root\"));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/state.png\"/&gt; &lt;/div&gt;## 10.state其它特性 - 合并更新、异步更新、preState:返回回调函数```javascriptimport React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//函数组件没有内部状态，只有类组件有内部状态////setState//改变state值//render方法再次执行，生成新的virtural DOM结构//比较新旧virtual DOM的结构，对变化部分进行更新//state的 其它特性// 什么是内部状态// 合并更新// 异步更新// 语法//// 如果你用到了constructor就必须写super(),是用来初始化this的，可以绑定事件到this上;// 如果你在constructor中要使用this.props,就必须给super加参数：super(props)；class MagicNumber extends Component { constructor(props) { super(props); console.log(this.props); //必须 super(props)，负责无法访问到 this。props this.state = { number: Math.random(), name: props.name }; } render() { /*console.log(this.state);*/ let { number, name } = this.state; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={() =&gt; { let num = Math.random(); this.setState({ number: num }); console.log(this.state.number,num);//异步更新state状态，比较前后值不一样 this.setState({ name: \"Make\" });//合并更新 this.setState((prevState,props)=&gt;{//回调函数 console.log(prevState);//获取state之前的状态 return{ name:\"Roy\", number:prevState.number === num ? 1 : 0 } }); }} &gt; change number &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;MagicNumber name=\"m2\" /&gt; &lt;MagicNumber name=\"m3\" /&gt; &lt;MagicNumber name=\"m4\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 11.事件系统 事件系统 合成事件对象 支持的事件 this指向 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//函数组件没有内部状态，只有类组件有内部状态////setState//改变state值//render方法再次执行，生成新的virtural DOM结构//比较新旧virtual DOM的结构，对变化部分进行更新//state的 其它特性// 什么是内部状态// 合并更新// 异步更新// 语法//// 如果你用到了constructor就必须写super(),是用来初始化this的，可以绑定事件到this上;// 如果你在constructor中要使用this.props,就必须给super加参数：super(props)；class MagicNumber extends Component { constructor(props) { super(props); console.log(this.props); //必须 super(props)，负责无法访问到 this。props this.state = { number: Math.random(), name: props.name }; } render() { /*console.log(this.state);*/ let { number, name } = this.state; return ( &lt;div onClick={(event)=&gt;{ console.log('冒泡到这里啦'); console.log(event.currentTarget);//当前事件 console.log(event.target);// }}&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={(event) =&gt; { console.log(event.nativeEvent);//浏览器原生事件对象 event.stopPropagation(); this.setState({ number: Math.random() }); }} &gt; change number &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;MagicNumber name=\"m2\" /&gt; &lt;MagicNumber name=\"m3\" /&gt; &lt;MagicNumber name=\"m4\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 12.事件系统中this指向 this指向:4种解决方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//事件系统// 合成事件对象// 支持的事件对象// this指向// 行内绑定this// 行内使用箭头函数// 在constructor中绑定this// 类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定thisclass MagicNumber extends Component { constructor(props) { super(props); console.log(this.props); //必须 super(props)，负责无法访问到 this。props this.state = { number: Math.random(), name: props.name }; this.handleButtonClick = this.handleButtonClick.bind(this); } handleButtonClick(event){//把回调函数写到这，直接写在标签里面，太乱 console.log(event.target);//获取触发的事件对象 this.setState({ //在原生js中，this会指向button，但是react中，操作的是虚拟DOM，所以不知道是谁调用了 number: Math.random() }); } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this console.log(event.target);//获取触发的事件对象 this.setState({ //在原生js中，this会指向button，但是react中，操作的是虚拟DOM，所以不知道是谁调用了 number: Math.random() }); } render() { /*console.log(this.state);*/ let { number, name } = this.state; return ( &lt;div onClick={(event)=&gt;{ console.log('冒泡到这里啦'); console.log(event.currentTarget);//当前事件 console.log(event.target);// }}&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={(event) =&gt; {//箭头函数中，this指向由上下文决定的，本类调用了render方法，指向本类 console.log(event.nativeEvent);//浏览器原生事件对象 event.stopPropagation(); this.setState({ number: Math.random() }); }} &gt; change number &lt;/button&gt; &lt;button onClick={(function(event){//在原生js中，this会指向button，但是react中，操作的是虚拟DOM，所以不知道是谁调用了 console.log(event.nativeEvent);//浏览器原生事件对象 event.stopPropagation(); this.setState({ number: Math.random() }); }).bind(this)}//解决方法，绑定this &gt; change number 2 &lt;/button&gt; &lt;button onClick={this.handleButtonClick}//解决方法，绑定this &gt; change number 3 &lt;/button&gt; &lt;button onClick={this.handleButtonClicka}//解决方法，绑定this &gt; change number 4 &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;MagicNumber name=\"m2\" /&gt; &lt;MagicNumber name=\"m3\" /&gt; &lt;MagicNumber name=\"m4\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 13.生命周期 生命周期： Mounting 装载 constructor只执行一次 static getDerivedStateFromProps(props,state){} 在rander之前，给你一次改变state的机会，不改变返回null} render(){} componentDidMount(){}只执行一次 获取真实DOM元素， Update 更新 父组件更新,(已挂载)子组件也随着更新，但是子组件的构造函数值执行一次，所以想要同步父组件的props值，需要下面的方法 static getDerivedStateFromProps(props,state){} shouldComponentUpdate(nextProps,nextState){} 用于优化性能 返回一个Bool值 true:组件进行正常更新流程 false：后面的生命周期函数不会执行，界面也不会更新 render(){} getSnapshotBeforeUpdate(prevProps,prevState){}//更新前，获取快照 与下面的方法一起用 它更新前，新的virtualDOM已经计算出来了 但是，这个时候，浏览器 DOM 元素还没更新 判断 - componentDidUpdate(prevProps,prevState，snapShot){} - 更新完成后调用 - 获取真正的DOM元素 Unmounting 卸载 componentWilUnmount(){} 1.Mounting 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888' }; console.log(\"constructor mounting\")//mounting } static getDerivedStateFromProps(props,state){//mounting 获取props 与 state值，之后进行渲染,更改state console.log(props,state,\"mounting\") console.log(\"getDerivedStateFromProps mounting\"); console.log(document.getElementById('outDiv'),\"getDerivedStateFromProps\",\"mounting\")//获取真实dom,但是undefined return { name:props.name === state.name ? props.name + 'OK' : props.name + 'FAIL' }; } componentDidMount(){ console.log(\"组件装载完成 mounting\") console.log(document.getElementById('outDiv'),\"componentDidMount\",\"mounting\")//获取真实dom } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this console.log(event.target); this.setState({ number: Math.random() }); } render() { console.log(\"render mounting\");//mounting let { number, name } = this.state; return ( &lt;div id=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\"));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/mounting.png\"/&gt; &lt;/div&gt;- 2.Update 更新 ```javascriptimport React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888' }; console.log(\"constructor mounting\")//mounting } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this this.setState({ number: Math.random() }); } static getDerivedStateFromProps(props,state){//mounting 获取props 与 state值，之后进行渲染,更改state console.log(props,state,\"getDerivedStateFromProps\",\"mounting\") console.log(\"getDerivedStateFromProps mounting\"); console.log(document.getElementById('outDiv'),\"getDerivedStateFromProps\",\"mounting\")//获取真实dom,但是undefined return { name:props.name === state.name ? props.name + 'OK' : props.name + 'FAIL' }; } componentDidMount(){ console.log(\"组件装载完成 mounting\")//mounting console.log(document.getElementById('outDiv'),\"componentDidMount\",\"mounting\")//获取真实dom } //update shouldComponentUpdate(nextProps,nextState){//判断props与state值，变化，是否需要更新页面，页面不需要更新，返回false console.log(nextProps,nextState,\"shouldComponentUpdate\") return true;//返回false，后面的生命周期不执行 页面不刷新 } getSnapshotBeforeUpdate(prevProps,prevState){ return 'kkk getSnapshotBeforeUpdate'; } componentDidUpdate(prevProps,prevState,snapShot){ console.log(snapShot,\"componentDidUpdate\") } render() { console.log(\"render mounting\");//mounting let { number, name } = this.state; return ( &lt;div id=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; ----------------------------- &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){ super(props); this.state = { num : props.num } } //不调用这个方法，子组件的num 不会随着父组件的改变而改变 static getDerivedStateFromProps(props,state){//mounting return { num:props.num//这样才能，同步子组件与父组件的值 }; } render() { return ( &lt;div&gt;{this.state.num}&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\"));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/update.png\"/&gt; &lt;/div&gt;## 14.生命周期卸载与其他事项 - Unmounting 卸载 - componentWilUnmount(){} 执行一次```javascriptimport React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888' }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this this.setState({ number: Math.random() }); } render() { let { number, name } = this.state; return ( &lt;div id=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; {number&gt;0.5 &amp;&amp; &lt;Sun num={number} /&gt;} &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 15.生命周期错误捕获与总结 错误处理 componentDidCatch(error,info) 捕获子组件的生命周期抛出的错误 捕获不到本身组件抛出的错误 15.1 报错信息只在开发环境中，在页面显示，生产环境中不出现 运行结果 15.2 创建生产环境build npm run build 创建生产环境，build 全局安装 npm install -g serve serve -s build 非全局安装 npm install serve npx serve -s build 运行结果 运行结果,生产环境 页面中不显示错误信息，只有控制台可以看到 -15.3 捕获错误信息 {hasError ? ( Sun崩溃了 ) : ( )} 这段代码在开发环境中是不显示“Sun崩溃了”，只有在生产环境中显示 “Sun崩溃了” 运行结果：开发环境 运行结果：生产环境 npm run build 15.3 显示更少的生命周期 运行结果：生产环境 npm run build 15.4 总结 只有类组件才有生命周期，函数组件没有生命周期，无状态函数组件 16.获取真实DOM 回调ref 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false }; console.log(this.outDiv,\"constructor\");//真实DOM，还没有获取到 } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: Math.random() }); } componentDidMount(){ console.log(this.outDiv,\"componentDidMount\");//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" ref={el=&gt;this.outDiv = el}&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); createRef 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, { Component,createRef } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false }; /*console.log(this.outDiv,\"constructor\");//真实DOM，还没有获取到*/ //第二种获取真实DOM this.outDiv = createRef(); } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: Math.random() }); } componentDidMount(){ //第二种获取真实dom方式 console.log(this.outDiv.current,\"componentDidMount\");//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" `ref={this.outDiv}`&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 字符串（过时） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, { Component,createRef } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false }; /*console.log(this.outDiv,\"constructor\");//真实DOM，还没有获取到*/ //第二种获取真实DOM //this.outDiv = createRef(); } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: Math.random() }); } componentDidMount(){ //字符串的方式获取正式dom console.log(this.refs.outDiv,\"componentDidMount\");//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" ref=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 17.组件受控 不受控&lt;input type=&quot;text&quot; ref={(el)=&gt;this.input=el} /&gt;`javascriptimport React, { Component,createRef } from “react”; //引入react用来写jsx语法import ReactDOM from “react-dom”; class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + ‘888’, hasError:false }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: this.input.value }); } componentDidMount(){ //字符串的方式获取正式dom console.log(this.refs.outDiv,”componentDidMount”);//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,”render”);//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM {name} this.input=el} /&gt; {number}! —————————– &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }} class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log(‘Sun 创建’) } componentDidUpdate(){ console.log(‘Sun 更新’) } componentWillUnmount(){//只执行一次 console.log(‘Sun 卸载’) } render() { return ( SUN ); }} ReactDOM.render( , document.getElementById(“root”)); - 运行结果 &lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;https://realroyhsu.github.io/Img/React/input.png&quot;/&gt; &lt;/div&gt; - 组件受控:input里面无法输入值，需要通过改变state来获取值 ```javascript import React, { Component,createRef } from &quot;react&quot;; //引入react用来写jsx语法 import ReactDOM from &quot;react-dom&quot;; class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + &apos;888&apos;, hasError:false, //受控 inputValue:&quot;&quot; }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: this.state.inputValue, //清空input inputValue:&apos;&apos; }); } //受控input获取值 handleInputChange=(event) =&gt; { let value = event.target.value; this.setState({ inputValue:value + &quot;00&quot; }) } render() { let { number, name,hasError,inputValue} = this.state; console.log(this.outDiv,&quot;render&quot;);//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=&quot;outDiv&quot; ref=&quot;outDiv&quot;&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;input type=&quot;text&quot; value={inputValue} onChange={this.handleInputChange} ref={(el)=&gt;this.input=el} /&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); } } class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log(&apos;Sun 创建&apos;) } componentDidUpdate(){ console.log(&apos;Sun 更新&apos;) } componentWillUnmount(){//只执行一次 console.log(&apos;Sun 卸载&apos;) } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); } } ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=&quot;m1&quot; /&gt; &lt;/div&gt;, document.getElementById(&quot;root&quot;) ); 运行结果 18.基于回调的组件交流 兄弟组件间的通信 import React, { Component,createRef } from \"react\"; //引入react用来写jsx语法 import ReactDOM from \"react-dom\"; class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false, //受控 inputValue:\"\", msg:'fadsf' }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: this.state.inputValue, //清空input inputValue:'' }); } //受控input获取值 handleInputChange=(event) =&gt; { let value = event.target.value; this.setState({ inputValue:value + \"00\" }) } //改变兄弟组件间的值 changeMsg=(value)=&gt;{ this.setState({ msg: value }) } render() { let { number, name,hasError,inputValue,msg} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" ref=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;input type=\"text\" value={inputValue} onChange={this.handleInputChange} ref={(el)=&gt;this.input=el} /&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Send changeMsg={this.changeMsg}/&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Receive msg={msg}/&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;button onClick={()=&gt;this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); } } &lt;!-- &lt;div style=\"background:red;\"&gt; --&gt; function Send(props){ return ( &lt;div&gt; &lt;h2&gt;发送消息&lt;/h2&gt; &lt;button onClick={()=&gt;props.changeMsg(Math.random())}&gt;Send&lt;/button&gt; &lt;/div&gt; ) } function Receive(props){ return ( &lt;div&gt; &lt;h2&gt;接收消息&lt;/h2&gt; &lt;p&gt;{props.msg}&lt;/p&gt; &lt;/div&gt; ) } &lt;!-- &lt;/div&gt; --&gt; ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\") ); 运行结果","link":"/2018/11/27/2018-11-27 React最佳入门/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Atom","slug":"Atom","link":"/tags/Atom/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"This","slug":"This","link":"/tags/This/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"}],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Atom","slug":"Atom","link":"/categories/Atom/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Sublime","slug":"Sublime","link":"/categories/Sublime/"},{"name":"Ajax","slug":"Ajax","link":"/categories/Ajax/"},{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"Object","slug":"Object","link":"/categories/Object/"},{"name":"This","slug":"This","link":"/categories/This/"},{"name":"Vuex","slug":"Vuex","link":"/categories/Vuex/"}]}