{"pages":[],"posts":[{"title":"SSH远程连接Google的Compute Engine","text":"在您的工作站上打开一个终端，再使用 ssh-keygen 命令生成新的密钥。指定 -C 标志以添加一条带有您的用户名的注释。 在您的工作站上打开一个终端，再使用 ssh-keygen 命令生成新的密钥。指定 -C 标志以添加一条带有您的用户名的注释。 1、ssh-keygen -t rsa -f ~/.ssh/[KEY_FILENAME] -C [USERNAME] 其中： [KEY_FILENAME] 是您要用于 SSH 密钥文件的名称。例如，文件名 my-ssh-key 生成一个名为 my-ssh-key 的私钥文件和一个名为 my-ssh-key.pub 公钥文件。 [USERNAME] 是您要为其应用此 SSH 密钥的用户。 该命令生成一个 SSH 私钥文件和一个匹配的 SSH 公钥，公钥结构如下所示：ssh-rsa [KEY_VALUE] [USERNAME] 其中：[KEY_VALUE] 是您生成的密钥值。[USERNAME] 是此密钥要应用到的用户。 2、限制对您的私钥的访问，以便只有您能读取此密钥，且所有人都不可向其写入。 chmod 400 ~/.ssh/[KEY_FILENAME] 其中 [KEY_FILENAME] 是您用于 SSH 密钥文件的名称。 3、要使用 ssh 连接到实例，请执行以下操作： 1、使用其中一个可用选项为实例提供 SSH 公钥。 1、cat google.pub 2、生成的公钥内容要复制出来 3、粘贴到Compute Engine的 元数据中 2、在控制台中，查找要连接到的实例的外部 IP 地址。转到您的实例列表。 3、在终端中，使用 ssh 命令和 SSH 私钥文件连接到实例。指定您的用户名和您要连接到的实例的外部 IP 地址。 ssh -i [PATH_TO_PRIVATE_KEY] [USERNAME]@[EXTERNAL_IP_ADDRESS] 其中：[PATH_TO_PRIVATE_KEY] 是您的 SSH 私钥文件的路径。[USERNAME] 是连接到实例的用户的名称。在创建 SSH 密钥时，就指定了该 SSH 公钥的用户名。如果实例具有该用户的有效 SSH 公钥，并且您拥有与之匹配的 SSH 私钥，则您可以以该用户的身份连接到此实例。[EXTERNAL_IP_ADDRESS] 是您的实例的外部 IP 地址。如果连接成功，您就可以使用终端在您的实例上运行命令。完成操作后，可使用 exit 命令断开与实例的连接。","link":"/2018/10/28/SSH远程连接Google的Compute Engine/"},{"title":"this指向和get、set中this指向","text":"1.全局环境2.事件处理函数3.函数内部4.getter 和 setter 中 this 1.全局环境 window 123&lt;script&gt; console.log( this ); //Window&lt;/script&gt; 1234567var box = document.getElementById(\"box\");box.onclick = function(){ setTimeout( function(){ console.log( this ); // window this.style.backgroundColor = \"red\"; },1000 )} 2.事件处理函数 DOM 事件处理函数 12345var box = document.getElementById(\"box\");box.onclick = function(){ console.log( this ); // 事件处理函数中的 this, 该事件由谁触发,this指的就是谁 //此处this返回：&lt;div id=\"box\" &gt;div&lt;/div&gt;} 内联事件处理函数 1234&lt;div id=\"box\" onclick=\"console.log( this )\" &gt;div&lt;/div&gt;&lt;!-- 此处this指向：&lt;div id=\"box\" onclick=\"console.log( this )\" &gt;div&lt;/div&gt; --&gt;&lt;div id=\"box\" onclick=\"( (function(){console.log( this )})() )\" &gt;div&lt;/div&gt;&lt;!-- 此处this指向：window --&gt; 3.函数内部 1.函数直接执行 非严格模式下 默认指向全局对象 浏览器 12345function fn(){ console.log(this);}fn();//此处this，指向windowwindow.fn();//此处this，指向window node node交互界面中 js文件中 严格模式下(前面省略window,浏览器严格模式支持) undefined 123456function fn(){ \"use strict\" console.log(this);}fn();//此处this，打印 undefinedwindow.fn();//此处this，指向window 2.call,apply和bind 把 this 的值从一个执行环境传入另一个执行环境 call apply 改变指向同时，运行函数 call 和 apply 的参数差异:apply 可以传【数组】 如果传入的不是对象会调用相对的构造函数,进行隐式转换 1234567function fn(m,n){ console.log( this.a,m,n );}fn.call( {a: 1},2,3 );// 函数.call 会直接调用该函数.// 并且call 的 第 0个参数就是 函数执行时候的this 指向第0个对象// 后面的参数是 函数执行的时候的参数 bind bind只改变指向，不会调用方法 返回一个新函数,内部this指向被修改 只会改变一次 1234567891011121314151617181920function fn(){ console.log( this.a )}fn();// this指向undefinedvar fn1 = fn.bind( {a: 2} );var fn2 = fn.bind( {a: 3} );var fn3 = fn.bind( {a: 4} );console.log( fn1 );//ƒ fn(){// console.log( this.a )// }fn1();//打印 2fn2();//打印 3fn3();//打印 4var fn4 = fn1.bind( {a:100} );fn4();//打印 2 bind只会改变一次 , 所以 还是打印 第一次bind的对象 传入数字，打印数字类型 12345function fn(){ console.log( this )}var fn1 = fn.bind(1);fn1(); //this指向 Number 3.箭头函数内部 与定义时的环境中 this 一致 点击元素定时改变 1234567891011121314&lt;div id=\"box\"&gt;box&lt;/div&gt;&lt;script&gt; var fn = ()=&gt;{ console.log( this ); // this指向window } fn(); box.onclick = function(){ console.log( this );// this指向box setTimeout( ()=&gt;{ // 箭头函数中，this指向与定义时的环境中 this 一致 //如果这个是function， this.style.backgroundColor，会报错，因为this指向window； 而window原型中没有backgroundColor this.style.backgroundColor = \"red\";//this指向box },500 ) }&lt;/script&gt; bind,call 不能修改其内部指向 全局中定义箭头函数 全局对象 12345var fn = ()=&gt;{ console.log( this )//this指向window}var fn1 = fn.bind( {} );//bind,call 不能修改其箭头函数内部指向fn1();//this指向window 对象内函数定义箭头函数 对象内部this指向window 1234567891011121314var a = 1;var obj = { a: 2, b:this, fn1: ()=&gt;{ console.log( this.a ) }, fn2: function(){ console.log( this.a ) }}console.log(obj.b);//打印window 对象内部this指向windowobj.fn1();//打印1 this指向windowobj.fn2();//打印2 this指向obj 对象内函数返回箭头函数 function函数，原则是谁调用指向谁 箭头函数，原则是在哪定义，this指向谁，并且不能被call、bind的改变指向 与上面中有所区别，对于箭头函数，return 箭头函数，里面this指向是不变的 1234567891011121314151617181920212223242526272829303132333435363738394041424344var a = 1;var obj = { a: 2, fn1: function(){ console.log( this.a )//谁调用指向谁 return function(){ console.log( this.a )//谁调用指向谁 } }, fn2: ()=&gt;{ console.log(this.a);//this指向window return ()=&gt;{ console.log( this.a );//this指向window } }, fn3: ()=&gt;{ console.log(this.a);//this指向window return function(){ console.log( this.a );//谁调用指向谁 } }, fn4: function(){ console.log(this.a);//谁调用指向谁 return ()=&gt;{ console.log( this.a );//this指向 fn4中，与function内部this指向一样 } }}var innerFn1 = obj.fn1();//打印 2console.log(innerFn1);//这里 innerFn1 = return出来的 functioninnerFn1();//打印 1 this指向window，谁调用指向谁var innerFn2 = obj.fn2();//打印 1innerFn2();//打印1 this指向windowvar innerFn3 = obj.fn3();//打印 1innerFn3();//打印1 this指向window，谁调用指向谁var innerFn4 = obj.fn4();//打印 2console.log(innerFn4);//这里 innerFn4 = return出来的 ()=&gt;{}innerFn4();//打印 2 this指向 fn4中，与function内部this指向一样 4.对象方法内部 当函数作为对象里的方法被调用时 调用该函数的对象 123456789var a = 1;var obj = { a: 2, fn: function(){ console.log( this.a ) }}obj.fn();//2obj.fn.bind({a: \"momo\"})();//momo 对象后续附属上的方法调用 调用该函数的对象 1234567891011121314var obj = { a: 1};var fn = function(){ console.log(this.a)}obj.fn = fn;//与上面中，实际一样，对象赋值，指向同一个对象obj.fn();//1//-------------------------------------var fn1 = ()=&gt;{ console.log(this.a)}obj.fn1 = fn1;obj.fn1();//undefined 箭头函数this定义时，就确定指向 作为函数内嵌套多层的方法调用 就近绑定 12345678910111213var a = 1;var obj = { a: 2, o: { a: 3, fn: function(){ console.log(this.a) } }};obj.o.fn();//3 就近绑定var temp = obj.o.fn;temp();//1 谁调用this指向谁 5.构造函数中 构造函数中没有显式return 12345function Fn(){ this.a = 10;}var f = new Fn();//this指向实例化过程，创建出来的对象 f console.log( f );//{a: 1, fn: ƒ} 构造函数中显式return return 对象 return 非对象 1234567function Fn(){ this.a = 10; //return 1; //返回非 null 的对象,那么实例化结果就是返回出的对象 Fn {a: 10} return {}; //返回非 null 的对象,那么实例化结果就是返回出的对象 {}}var f = new Fn();//this指向实例化过程，创建出来的对象 f console.log( f ); 6.原型链上函数 调用该函数的对象 1234567891011var p = { a: 1, fn: function(){ console.log( this.a ) }}var c = Object.create( p );//以p对象来复制一个对象console.log(c);//打印空对象{}console.log( c.__proto__ );//打印p对象 {a: 1, fn: ƒ}console.log( c.a );//打印1 c没有a属性，会往原型链上找c.fn();//打印1 c调用fn方法，this指向c对象，但是c上没有a属性，会往原型链上找 4.getter 和 setter 中 this get 访问 set 设置 123456789101112131415var obj = { n: 1, m: 2, get sum(){//拦截 在控制台中，obj.sum console.log( \"正在尝试访问 sum...\" ) // return 2 return this.n+this.m//这里this指向obj }, set sum(zm){//拦截 在控制台中，obj.sum = 24 console.log( \"正在设置 sum...\" ); this.n = zm/2;//这里this指向obj this.m = zm/2; }}// console.log( obj.sum )","link":"/2018/11/04/this指向和get、set中this指向/"},{"title":"Sublime3 React、JSX 代码美化--[Prettier]","text":"最近一直用Sublime写React项目，但是jsx语法格式化一直让我头疼。尝试了JsFormat、jsfmt、HTML/CSS/JS pretty、esformatter等都没有完美的解决我的问题结果惨不忍睹： 最近一直用Sublime写React项目，但是jsx语法格式化一直让我头疼。尝试了JsFormat、jsfmt、HTML/CSS/JS pretty、esformatter等都没有完美的解决我的问题结果惨不忍睹： Prettier官网 JsPrettier is a Sublime Text Plug-in for Prettier, the opinionated code formatter.网传facebook也是在用它优化React项目 开始安装插件 -g 全局安装npm install -g prettier sublime text3 直接在package control搜索prettier下载，打开它的User配置项加入如下保存即可。 修改配置文件Preferences&gt;PackageSettings&gt;JsPrettier&gt;Settings User 1234567891011121314151617181920212223{ \"debug\": false, \"prettier_cli_path\": \"C:/Users/njwb/AppData/Roaming/npm/node_modules/prettier/bin-prettier.js\", \"node_path\": \"C:/Program Files/nodejs/node.exe\", \"auto_format_on_save\": false, \"auto_format_on_save_excludes\": [], \"allow_inline_formatting\": false, \"custom_file_extensions\": [], \"max_file_size_limit\": -1, \"additional_cli_args\": {}, \"prettier_options\": { \"printWidth\": 80, \"singleQuote\": false, \"trailingComma\": \"none\", \"bracketSpacing\": true, \"jsxBracketSameLine\": false, \"parser\": \"babylon\", \"semi\": true, \"requirePragma\": false, \"proseWrap\": \"preserve\", \"arrowParens\": \"avoid\" }} “prettier_cli_path”: 是你全局安装prettier插件的路径“node_path”: 是你nodejs安装的路径 在项目根目录下面建一个 .prettierrc 文件,并配置1234567891011{ \"printWidth\": 120, // 换行字符串阈值 \"semi\": true, // 句末加分号 \"singleQuote\": true, // 用单引号 \"trailingComma\": \"none\", // 最后一个对象元素加逗号 \"bracketSpacing\": true, // 对象，数组加空格 \"jsxBracketSameLine\": false, // jsx &gt; 是否另起一行 \"arrowParens\": \"avoid\", // (x) =&gt; {} 是否要有小括号 \"requirePragma\": false, // 是否要注释来决定是否格式化代码 \"proseWrap\": \"preserve\" // 是否要换行} 修改快捷键1234{ \"keys\": [\"ctrl+shift+j\"], \"command\": \"js_prettier\"} 如果按照本教程出现插件还是无法使用,请输入Ctrl + ·，查看控制台是否有报错它会提示你哪里有错误，Prettier官网 错可能情况有： React文件中，有单标签没有闭合：img input 配置文件中符号为中文 完美的解决了React格式化问题","link":"/2018/09/02/Sublime3 React、JSX 代码美化--[Prettier]/"},{"title":"关于jquery中的ajax调取数据成功回调函数，失败回调函数","text":"通常，ajax调取数据，在pc端的时候，我们不需要考虑断网情况，所以很多情况下我们都只需要如下格式： 通常，ajax调取数据，在pc端的时候，我们不需要考虑断网情况，所以很多情况下我们都只需要如下格式： 即可实现ajax调取后台数据，我这里用的是jsonp跨域调取的数据。 但是在移动端就不一样了，在app上，我们通常要考虑手机断网的情况，而我们上一段的代码中，error只是提示我们报错的原因或状态，并不能执行我们网络错误以后的回调函数，所以我们需要改动一下以上的代码。如下： 我用红线框出来的部分需要注意，在断网情况下，必须要设定timeout的值，你可以根据自己想要设定的时间，即表示在加载超过多少秒后就判断为断网了，在这里我设定的值是5秒，即在五秒后若没有获取到数据就进入失败回调函数。同时async:true必须设定为异步的形式，这里我没有进行设置即默认是异步的， 那么我们就可以在失败回调函数中进行我们想要的操作了。","link":"/2018/09/27/关于jquery中的ajax调取数据成功回调函数，失败回调函数/"},{"title":"React最佳入门","text":"React最佳入门 1.运行Hello React 2.认识jsx 3.jsx使用方式 4.认识组件 5.认识props 6.children和类组件的props 7.defaultProps 8.prop-types 9.内部状态state 10.state其它特性 11.事件系统 12.事件系统中this指向 13.生命周期 14.生命周期卸载与其他事项 15.生命周期错误捕获与总结 16.获取真实DOM 17.组件受控 18.基于回调的组件交流 React最佳入门 1.运行Hello React 1.1 全局安装React脚手架：1234npm install -g create-react-app create-react-app my-app cd my-app npm start 1.2 删除项目src下的所有文件，重新创建 整个项目的入口文件 index.js,编写代码，浏览器即使更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//把你写的结构，通过js渲染到页面上//下面的html，是jsx语法，本质上也是js代码ReactDOM.render( &lt;div&gt;Hello World!&lt;/div&gt;, document.getElementById('root'));``` ## 2.认识jsx &gt;每次打开React项目可以先运行 `npm i`, 安装package.json所需要的插件 &gt;安装完成后，项目中会多一个node_modules文件- 2.1 `npm i`&lt;div align=\"center\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/npminstall.png\"/&gt;&lt;/div&gt; - 2.2 我们可以用babel工具来转换jsx代码，可以看出jsx语法，被转换成了标准的js语法；而且通过React.createElement()方式创建，所以我们需要引入 `import React from 'react';//引入react用来写jsx语法` &lt;div align=\"center\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/jsx.png\"/&gt; &lt;/div&gt;- 2.3 我看可以看出jsx生成的格式，通过React创建节点，ReactDOM再来插入节点 **jsx其实就是写结构的语法糖，它会被babel这个工具转变成 js 代码，这个js代码运行后会得到一个对象** **这个对象就是virtual DOM** &lt;div align=\"center\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/jsxhtml.png\"/&gt; &lt;/div&gt;## 3.jsx使用方式 - 3.1 jsx中使用表达式 ```javascriptimport React,{Fragment} from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//把你写的结构，通过js渲染到页面上//下面的html，是jsx语法，本质上也是js代码let jsx3 = (&lt;Fragment&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/Fragment&gt;);ReactDOM.render( &lt;div&gt; {/*变量直接拼接hello world*/} {s1+' '+s2} {/*模板字符串拼接 hello world*/} {`${s1} ${s2}`} {/*15*/} {6+9} {/*3*/} &lt;p&gt;{sum(1,2)}&lt;/p&gt; {/*如果前面值成立，返回jeo*/} &lt;p&gt;{'hj' &amp;&amp; 'jeo'}&lt;/p&gt; **{/*只能写表达式，不可以写if for等语句，可以写三目运算*/}** {/*嵌入变量*/} {jsx1} {jsx2} {/*嵌入变量,必须有一个闭合标签包含可以用div*/} {jsx3} {/*如果是li,可以用Fragment，来包含,这样就不会多div标签*/} &lt;ul&gt;{jsx3}&lt;/ul&gt; &lt;/div&gt;, document.getElementById('root')); 3.3 jsx 中的闭合 1234567891011121314151617181920 ReactDOM.render( &lt;div&gt; {/*标签闭合*/} &lt;div /&gt; &lt;/div&gt;, document.getElementById('root'));``` - 3.4 样式 也可以采用 import './css'```javascript ReactDOM.render( &lt;div&gt; {/*标签闭合*/} &lt;p style={{color:'red',marginLeft:50}}&gt;&lt;/p&gt; &lt;/div&gt;, document.getElementById('root')); 3.5 属性:关键字属性 className“-“ 相邻的，采用驼峰写法 1234567 ReactDOM.render( &lt;div&gt; {/*标签闭合*/} &lt;p className='kkk' style={{color:'red',marginLeft:50}}&gt;&lt;/p&gt; &lt;/div&gt;, document.getElementById('root')); 4.认识组件 4.1 函数组件与类组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//1.组件的表现形式// 函数组件// 类组件//2.使用组件// 标签名大写开头// 变量在作用域内// 小写开头的是dom组件`&lt;vv&gt;ds&lt;/vv&gt;`//3.组件相互嵌套//函数组件function People(){ return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是people&lt;/h2&gt; &lt;/div&gt; )}//类组件class Man extends React.Component{ render(){ return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; {/*组件相互嵌套*/} &lt;People /&gt; &lt;/div&gt; ) }}ReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People /&gt; &lt;People /&gt; &lt;Man /&gt; &lt;/div&gt;, document.getElementById('root')); 4.2 函数组件与类组件分别写入不同的文件中 创建People.js组件 123456789import React from 'react';//函数组件export default function People(){ return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是people&lt;/h2&gt; &lt;/div&gt; )} 创建Man.js组件 1234567891011121314import React,{Component} from 'react';import People from './People.js';//引入people组件//类组件export default class Man extends React.Component{ render(){ return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; &lt;People /&gt; &lt;/div&gt; ) }} 修改index.js入口文件 1234567891011121314151617181920212223242526import React from 'react';//引入react用来写jsx语法import ReactDOM from 'react-dom';//1.组件的表现形式// 函数组件// 类组件//2.使用组件// 标签名大写开头// 变量在作用域内// 小写开头的是dom组件`&lt;vv&gt;ds&lt;/vv&gt;`//3.组件相互嵌套import People from './People.js';import Man from './Man.js';ReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People /&gt; &lt;People /&gt; &lt;Man /&gt; &lt;/div&gt;, document.getElementById('root')); 5.认识props 创建People.js组件 123456789101112131415161718192021222324252627282930313233 import React from 'react'; //函数组件 export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;h2&gt;我的年龄:{props.age}&lt;/h2&gt; &lt;h2&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/h2&gt; &lt;/div&gt; ) } ``` - 创建Man.js组件 ```javascript import React,{Component} from 'react'; import People from './People.js';//引入people组件 //类组件 export default class Man extends React.Component{ render(){ return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; &lt;People /&gt; &lt;/div&gt; ) } } 修改index.js入口文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 import React from 'react';//引入react用来写jsx语法 import ReactDOM from 'react-dom'; //1.组件的表现形式 // 函数组件 // 类组件 //2.使用组件 // 标签名大写开头 // 变量在作用域内 // 小写开头的是dom组件`&lt;vv&gt;ds&lt;/vv&gt;` //3.组件相互嵌套 import People from './People.js'; import Man from './Man.js'; //在自定义属性里面，可以直接写一些属性，然后接上一些值 //在函数组件中，通过第一个参数来接受props // ReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt/&gt; &lt;People /&gt; &lt;Man /&gt; &lt;/div&gt;, document.getElementById('root') ); ``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/props.png\"/&gt; &lt;/div&gt;## 6.children和类组件的props- 创建People.js组件 ```javascript import React from 'react'; //函数组件 export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;h2&gt;我的年龄:{props.age}&lt;/h2&gt; &lt;h2&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/h2&gt; &lt;div&gt;{props.children}&lt;/div&gt; &lt;/div&gt; ) } 创建Man.js组件 1234567891011121314151617181920import React,{Component} from 'react';import People from './People.js';//引入people组件//类组件export default class Man extends React.Component{ render(){ /*console.log(this.props)*/ /*在类组件里面，通过组件实例下面的props:this.props*/ let {eyes,hand,peopleName,children} = this.props; return( &lt;div className=\"man\"&gt; &lt;h2&gt;我是man&lt;/h2&gt; &lt;h2&gt;我有{hand}只手&lt;/h2&gt; &lt;h2&gt;我有{eyes}只眼&lt;/h2&gt; &lt;People name={peopleName} age={122} /&gt; {children} &lt;/div&gt; ) }} 修改index.js入口文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 import React from 'react';//引入react用来写jsx语法 import ReactDOM from 'react-dom'; import People from './People.js'; import Man from './Man.js'; //类组件与函数组件区别 //1.接受props不同 //2.类组件有实例 this，函数组件没有实例 // // //在自定义属性里面，可以直接写一些属性，然后接上一些值 //在函数组件中，通过第一个参数来接受props //在类组件里面，通过组件实例下面的props:this.props //数组是从父组件传给子组件 props //children //组件标签之间的内容就是children ReactDOM.render( &lt;div&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt children={&lt;div&gt;我是people下的children，我从index来&lt;/div&gt;}&gt; {/*children*/} 1234 &lt;/People&gt; &lt;Man eyes={1000} hand={100} peopleName=\"flower\"&gt; 我是index传来的children &lt;/Man&gt; &lt;/div&gt;, document.getElementById('root') ); ``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/propschildren.png\"/&gt; &lt;/div&gt; ## 7.defaultProps - 创建People.js组件 ```javascript import React from 'react'; //函数组件 export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;h2&gt;我的年龄:{props.age}&lt;/h2&gt; &lt;h2&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/h2&gt; &lt;div&gt;{props.children}&lt;/div&gt; &lt;/div&gt; ) } 创建Man.js组件 123456789101112131415161718192021222324252627import React from 'react';//函数组件export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;p&gt;我的年龄:{props.age}&lt;/p&gt; &lt;p&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/p&gt; &lt;div&gt;{props.children}&lt;/div&gt; {/*直接获取父组件传来的函数会报错,因为在其他people组件的，并没有传函数；TypeError: props.renderProps is not a function*/} {props.renderProps()} &lt;/div&gt; )}//只有在undefined情况下，获取默认值People.defaultProps={ name:'----------', age:'11111111111', /*可以给它一个默认属性，就不或报错*/ renderProps:()=&gt;{}} 修改index.js入口文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 import React from 'react';//引入react用来写jsx语法 import ReactDOM from 'react-dom'; import People from './People.js'; import Man from './Man.js'; //defaultProps //给参数设置默认值 //：不然给子组件传递函数方法时，如果有多个子组件，没有全部传递函数方法，会报错 如下：renderProps={()=&gt;Math.random()} ReactDOM.render( &lt;div&gt; &lt;People renderProps={()=&gt;Math.random()}/&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt children={&lt;div&gt;我是people下的children，我从index来&lt;/div&gt;}&gt; {/*children*/} 1234 &lt;/People&gt; &lt;Man eyes={1000} hand={100} peopleName=\"flower\"&gt; 我是index传来的children &lt;/Man&gt; &lt;/div&gt;, document.getElementById('root') ); ``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/defaultPROPS.png\"/&gt; &lt;/div&gt; ## 8.prop-types &gt;安装：`npm install --save prop-types` - 创建People.js组件 ```javascript import React from 'react'; import PT from 'prop-types' //函数组件 export default function People(props){ console.log(props); return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;p&gt;我的年龄:{props.age}&lt;/p&gt; &lt;p&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/p&gt; &lt;div&gt;{props.children}&lt;/div&gt; {/*直接获取父组件传来的函数会报错,因为在其他people组件的，并没有传函数；TypeError: props.renderProps is not a function*/} {props.renderProps()} &lt;/div&gt; ) } //只有在undefined情况下，获取默认值 People.defaultProps={ name:'----------', age:'11111111111', /*可以给它一个默认属性，就不或报错*/ renderProps:()=&gt;{} } //数据类型验证 People.propTypes={ name:PT.string, age:PT.number, renderProps:PT.func } 创建Man.js组件 123456789101112131415161718192021222324252627import React from 'react';//函数组件export default function People(props){ console.log(props) return ( &lt;div className=\"people\"&gt; &lt;h2&gt;我是:{props.name}&lt;/h2&gt; &lt;p&gt;我的年龄:{props.age}&lt;/p&gt; &lt;p&gt;是本人吗:{props.isSelf} ? '是' ： '不是'&lt;/p&gt; &lt;div&gt;{props.children}&lt;/div&gt; {/*直接获取父组件传来的函数会报错,因为在其他people组件的，并没有传函数；TypeError: props.renderProps is not a function*/} {props.renderProps()} &lt;/div&gt; )}//只有在undefined情况下，获取默认值People.defaultProps={ name:'----------', age:'11111111111', /*可以给它一个默认属性，就不或报错*/ renderProps:()=&gt;{}} 修改index.js入口文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155 import React from 'react';//引入react用来写jsx语法 import ReactDOM from 'react-dom'; import People from './People.js'; import Man from './Man.js'; //defaultProps //给参数设置默认值 //：不然给子组件传递函数方法时，如果有多个子组件，没有全部传递函数方法，会报错 如下：renderProps={()=&gt;Math.random()} ReactDOM.render( &lt;div&gt; &lt;People renderProps={()=&gt;Math.random()}/&gt; &lt;vv&gt;ds&lt;/vv&gt; 认识组件 &lt;People name=\"jeo\" age={90} isSelt children={&lt;div&gt;我是people下的children，我从index来&lt;/div&gt;}&gt; {/*children*/} 1234 &lt;/People&gt; &lt;Man eyes={1000} hand={100} peopleName=\"flower\"&gt; 我是index传来的children &lt;/Man&gt; &lt;/div&gt;, document.getElementById('root') ); ``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/proptypes.png\"/&gt; &lt;/div&gt;## 9.内部状态state&gt;函数组件没有内部状态，只有类组件有内部状态- state、setState```javascriptimport React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//函数组件没有内部状态，只有类组件有内部状态////setState//改变state值//render方法再次执行，生成新的virtural DOM结构//比较新旧virtual DOM的结构，对变化部分进行更新class MagicNumber extends Component { constructor() { super(); this.state = { number:Math.random(), name:'joe' }; } render() { console.log(this.state); let {number,name} = this.state; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={()=&gt;{this.setState({number : Math.random()})}}&gt;change number&lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber /&gt; &lt;/div&gt;, document.getElementById(\"root\"));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/state.png\"/&gt; &lt;/div&gt;## 10.state其它特性 - 合并更新、异步更新、preState:返回回调函数```javascriptimport React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//函数组件没有内部状态，只有类组件有内部状态////setState//改变state值//render方法再次执行，生成新的virtural DOM结构//比较新旧virtual DOM的结构，对变化部分进行更新//state的 其它特性// 什么是内部状态// 合并更新// 异步更新// 语法//// 如果你用到了constructor就必须写super(),是用来初始化this的，可以绑定事件到this上;// 如果你在constructor中要使用this.props,就必须给super加参数：super(props)；class MagicNumber extends Component { constructor(props) { super(props); console.log(this.props); //必须 super(props)，负责无法访问到 this。props this.state = { number: Math.random(), name: props.name }; } render() { /*console.log(this.state);*/ let { number, name } = this.state; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={() =&gt; { let num = Math.random(); this.setState({ number: num }); console.log(this.state.number,num);//异步更新state状态，比较前后值不一样 this.setState({ name: \"Make\" });//合并更新 this.setState((prevState,props)=&gt;{//回调函数 console.log(prevState);//获取state之前的状态 return{ name:\"Roy\", number:prevState.number === num ? 1 : 0 } }); }} &gt; change number &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;MagicNumber name=\"m2\" /&gt; &lt;MagicNumber name=\"m3\" /&gt; &lt;MagicNumber name=\"m4\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 11.事件系统 事件系统 合成事件对象 支持的事件 this指向 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//函数组件没有内部状态，只有类组件有内部状态////setState//改变state值//render方法再次执行，生成新的virtural DOM结构//比较新旧virtual DOM的结构，对变化部分进行更新//state的 其它特性// 什么是内部状态// 合并更新// 异步更新// 语法//// 如果你用到了constructor就必须写super(),是用来初始化this的，可以绑定事件到this上;// 如果你在constructor中要使用this.props,就必须给super加参数：super(props)；class MagicNumber extends Component { constructor(props) { super(props); console.log(this.props); //必须 super(props)，负责无法访问到 this。props this.state = { number: Math.random(), name: props.name }; } render() { /*console.log(this.state);*/ let { number, name } = this.state; return ( &lt;div onClick={(event)=&gt;{ console.log('冒泡到这里啦'); console.log(event.currentTarget);//当前事件 console.log(event.target);// }}&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={(event) =&gt; { console.log(event.nativeEvent);//浏览器原生事件对象 event.stopPropagation(); this.setState({ number: Math.random() }); }} &gt; change number &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;MagicNumber name=\"m2\" /&gt; &lt;MagicNumber name=\"m3\" /&gt; &lt;MagicNumber name=\"m4\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 12.事件系统中this指向 this指向:4种解决方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";//事件系统// 合成事件对象// 支持的事件对象// this指向// 行内绑定this// 行内使用箭头函数// 在constructor中绑定this// 类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定thisclass MagicNumber extends Component { constructor(props) { super(props); console.log(this.props); //必须 super(props)，负责无法访问到 this。props this.state = { number: Math.random(), name: props.name }; this.handleButtonClick = this.handleButtonClick.bind(this); } handleButtonClick(event){//把回调函数写到这，直接写在标签里面，太乱 console.log(event.target);//获取触发的事件对象 this.setState({ //在原生js中，this会指向button，但是react中，操作的是虚拟DOM，所以不知道是谁调用了 number: Math.random() }); } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this console.log(event.target);//获取触发的事件对象 this.setState({ //在原生js中，this会指向button，但是react中，操作的是虚拟DOM，所以不知道是谁调用了 number: Math.random() }); } render() { /*console.log(this.state);*/ let { number, name } = this.state; return ( &lt;div onClick={(event)=&gt;{ console.log('冒泡到这里啦'); console.log(event.currentTarget);//当前事件 console.log(event.target);// }}&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={(event) =&gt; {//箭头函数中，this指向由上下文决定的，本类调用了render方法，指向本类 console.log(event.nativeEvent);//浏览器原生事件对象 event.stopPropagation(); this.setState({ number: Math.random() }); }} &gt; change number &lt;/button&gt; &lt;button onClick={(function(event){//在原生js中，this会指向button，但是react中，操作的是虚拟DOM，所以不知道是谁调用了 console.log(event.nativeEvent);//浏览器原生事件对象 event.stopPropagation(); this.setState({ number: Math.random() }); }).bind(this)}//解决方法，绑定this &gt; change number 2 &lt;/button&gt; &lt;button onClick={this.handleButtonClick}//解决方法，绑定this &gt; change number 3 &lt;/button&gt; &lt;button onClick={this.handleButtonClicka}//解决方法，绑定this &gt; change number 4 &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;MagicNumber name=\"m2\" /&gt; &lt;MagicNumber name=\"m3\" /&gt; &lt;MagicNumber name=\"m4\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 13.生命周期 生命周期： Mounting 装载 constructor只执行一次 static getDerivedStateFromProps(props,state){} 在rander之前，给你一次改变state的机会，不改变返回null} render(){} componentDidMount(){}只执行一次 获取真实DOM元素， Update 更新 父组件更新,(已挂载)子组件也随着更新，但是子组件的构造函数值执行一次，所以想要同步父组件的props值，需要下面的方法 static getDerivedStateFromProps(props,state){} shouldComponentUpdate(nextProps,nextState){} 用于优化性能 返回一个Bool值 true:组件进行正常更新流程 false：后面的生命周期函数不会执行，界面也不会更新 render(){} getSnapshotBeforeUpdate(prevProps,prevState){}//更新前，获取快照 与下面的方法一起用 它更新前，新的virtualDOM已经计算出来了 但是，这个时候，浏览器 DOM 元素还没更新 判断 - componentDidUpdate(prevProps,prevState，snapShot){} - 更新完成后调用 - 获取真正的DOM元素 Unmounting 卸载 componentWilUnmount(){} 1.Mounting 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888' }; console.log(\"constructor mounting\")//mounting } static getDerivedStateFromProps(props,state){//mounting 获取props 与 state值，之后进行渲染,更改state console.log(props,state,\"mounting\") console.log(\"getDerivedStateFromProps mounting\"); console.log(document.getElementById('outDiv'),\"getDerivedStateFromProps\",\"mounting\")//获取真实dom,但是undefined return { name:props.name === state.name ? props.name + 'OK' : props.name + 'FAIL' }; } componentDidMount(){ console.log(\"组件装载完成 mounting\") console.log(document.getElementById('outDiv'),\"componentDidMount\",\"mounting\")//获取真实dom } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this console.log(event.target); this.setState({ number: Math.random() }); } render() { console.log(\"render mounting\");//mounting let { number, name } = this.state; return ( &lt;div id=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\"));``` - 运行结果 &lt;div align=\"left\"&gt; &lt;img src=\"https://realroyhsu.github.io/Img/React/mounting.png\"/&gt; &lt;/div&gt;- 2.Update 更新 ```javascriptimport React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888' }; console.log(\"constructor mounting\")//mounting } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this this.setState({ number: Math.random() }); } static getDerivedStateFromProps(props,state){//mounting 获取props 与 state值，之后进行渲染,更改state console.log(props,state,\"getDerivedStateFromProps\",\"mounting\") console.log(\"getDerivedStateFromProps mounting\"); console.log(document.getElementById('outDiv'),\"getDerivedStateFromProps\",\"mounting\")//获取真实dom,但是undefined return { name:props.name === state.name ? props.name + 'OK' : props.name + 'FAIL' }; } componentDidMount(){ console.log(\"组件装载完成 mounting\")//mounting console.log(document.getElementById('outDiv'),\"componentDidMount\",\"mounting\")//获取真实dom } //update shouldComponentUpdate(nextProps,nextState){//判断props与state值，变化，是否需要更新页面，页面不需要更新，返回false console.log(nextProps,nextState,\"shouldComponentUpdate\") return true;//返回false，后面的生命周期不执行 页面不刷新 } getSnapshotBeforeUpdate(prevProps,prevState){ return 'kkk getSnapshotBeforeUpdate'; } componentDidUpdate(prevProps,prevState,snapShot){ console.log(snapShot,\"componentDidUpdate\") } render() { console.log(\"render mounting\");//mounting let { number, name } = this.state; return ( &lt;div id=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; ----------------------------- &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){ super(props); this.state = { num : props.num } } //不调用这个方法，子组件的num 不会随着父组件的改变而改变 static getDerivedStateFromProps(props,state){//mounting return { num:props.num//这样才能，同步子组件与父组件的值 }; } render() { return ( &lt;div&gt;{this.state.num}&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 14.生命周期卸载与其他事项 Unmounting 卸载 componentWilUnmount(){} 执行一次12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888' }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this this.setState({ number: Math.random() }); } render() { let { number, name } = this.state; return ( &lt;div id=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; {number&gt;0.5 &amp;&amp; &lt;Sun num={number} /&gt;} &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 15.生命周期错误捕获与总结 错误处理 componentDidCatch(error,info) 捕获子组件的生命周期抛出的错误 捕获不到本身组件抛出的错误 15.1 报错信息只在开发环境中，在页面显示，生产环境中不出现 运行结果 15.2 创建生产环境build npm run build 创建生产环境，build 全局安装 npm install -g serve serve -s build 非全局安装 npm install serve npx serve -s build 运行结果 运行结果,生产环境 页面中不显示错误信息，只有控制台可以看到 -15.3 捕获错误信息 {hasError ? ( Sun崩溃了 ) : ( )} 这段代码在开发环境中是不显示“Sun崩溃了”，只有在生产环境中显示 “Sun崩溃了” 运行结果：开发环境 运行结果：生产环境 npm run build 15.3 显示更少的生命周期 运行结果：生产环境 npm run build 15.4 总结 只有类组件才有生命周期，函数组件没有生命周期，无状态函数组件 16.获取真实DOM 回调ref 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, { Component } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false }; console.log(this.outDiv,\"constructor\");//真实DOM，还没有获取到 } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: Math.random() }); } componentDidMount(){ console.log(this.outDiv,\"componentDidMount\");//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" ref={el=&gt;this.outDiv = el}&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); createRef 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, { Component,createRef } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false }; /*console.log(this.outDiv,\"constructor\");//真实DOM，还没有获取到*/ //第二种获取真实DOM this.outDiv = createRef(); } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: Math.random() }); } componentDidMount(){ //第二种获取真实dom方式 console.log(this.outDiv.current,\"componentDidMount\");//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" `ref={this.outDiv}`&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 字符串（过时） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, { Component,createRef } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false }; /*console.log(this.outDiv,\"constructor\");//真实DOM，还没有获取到*/ //第二种获取真实DOM //this.outDiv = createRef(); } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: Math.random() }); } componentDidMount(){ //字符串的方式获取正式dom console.log(this.refs.outDiv,\"componentDidMount\");//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" ref=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 17.组件受控 不受控&lt;input type=&quot;text&quot; ref={(el)=&gt;this.input=el} /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import React, { Component,createRef } from \"react\"; //引入react用来写jsx语法import ReactDOM from \"react-dom\";class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + '888', hasError:false }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: this.input.value }); } componentDidMount(){ //字符串的方式获取正式dom console.log(this.refs.outDiv,\"componentDidMount\");//最先获取到DOM } componentDidCatch(error,info){//捕获错误信息 this.setState({ hasError:true }) } render() { let { number, name,hasError} = this.state; console.log(this.outDiv,\"render\");//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=\"outDiv\" ref=\"outDiv\"&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;input type=\"text\" ref={(el)=&gt;this.input=el} /&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }}class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log('Sun 创建') } componentDidUpdate(){ console.log('Sun 更新') } componentWillUnmount(){//只执行一次 console.log('Sun 卸载') } render() { return ( &lt;div&gt;SUN&lt;/div&gt; ); }}ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=\"m1\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 运行结果 组件受控:input里面无法输入值，需要通过改变state来获取值`javascriptimport React, { Component,createRef } from “react”; //引入react用来写jsx语法import ReactDOM from “react-dom”; class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + ‘888’, hasError:false, //受控 inputValue:”” }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: this.state.inputValue, //清空input inputValue:’’ }); } //受控input获取值 handleInputChange=(event) =&gt; { let value = event.target.value; this.setState({ inputValue:value + “00” }) } render() { let { number, name,hasError,inputValue} = this.state; console.log(this.outDiv,”render”);//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM {name} this.input=el} /&gt; {number}! —————————– &lt;Sun num={number} /&gt; &lt;button onClick={this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); }} class Sun extends Component{ constructor(props){//只执行一次 super(props); this.state = { num : props.num } } componentDidMount(){//只执行一次 console.log(‘Sun 创建’) } componentDidUpdate(){ console.log(‘Sun 更新’) } componentWillUnmount(){//只执行一次 console.log(‘Sun 卸载’) } render() { return ( SUN ); }} ReactDOM.render( , document.getElementById(“root”)); - 运行结果 &lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;https://realroyhsu.github.io/Img/React/inputvalue.png&quot;/&gt; &lt;/div&gt; ## 18.基于回调的组件交流 - 兄弟组件间的通信 ```javascript import React, { Component,createRef } from &quot;react&quot;; //引入react用来写jsx语法 import ReactDOM from &quot;react-dom&quot;; class MagicNumber extends Component { constructor(props) { super(props); this.state = { number: Math.random(), name: props.name + &apos;888&apos;, hasError:false, //受控 inputValue:&quot;&quot;, msg:&apos;fadsf&apos; }; } handleButtonClicka=(event)=&gt;{//类属性语法：可以写方法是，handleButtonClicka用箭头函数，自动绑定this //ref回调函数的方式，获取真实DOM console.log(this.outDiv) this.setState({ number: this.state.inputValue, //清空input inputValue:&apos;&apos; }); } //受控input获取值 handleInputChange=(event) =&gt; { let value = event.target.value; this.setState({ inputValue:value + &quot;00&quot; }) } //改变兄弟组件间的值 changeMsg=(value)=&gt;{ this.setState({ msg: value }) } render() { let { number, name,hasError,inputValue,msg} = this.state; console.log(this.outDiv,&quot;render&quot;);//真实DOM，还没有获取到,第一次加载时，还没获取到；点击后，可以获取到 return ( //ref回调函数的方式，获取真实DOM &lt;div id=&quot;outDiv&quot; ref=&quot;outDiv&quot;&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;input type=&quot;text&quot; value={inputValue} onChange={this.handleInputChange} ref={(el)=&gt;this.input=el} /&gt; &lt;p&gt;{number}!&lt;/p&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Send changeMsg={this.changeMsg}/&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;Receive msg={msg}/&gt; &lt;p&gt;-----------------------------&lt;/p&gt; &lt;button onClick={()=&gt;this.handleButtonClicka}&gt;change number 4&lt;/button&gt; &lt;/div&gt; ); } } &lt;!-- &lt;div style=&quot;background:red;&quot;&gt; --&gt; function Send(props){ return ( &lt;div&gt; &lt;h2&gt;发送消息&lt;/h2&gt; &lt;button onClick={()=&gt;props.changeMsg(Math.random())}&gt;Send&lt;/button&gt; &lt;/div&gt; ) } function Receive(props){ return ( &lt;div&gt; &lt;h2&gt;接收消息&lt;/h2&gt; &lt;p&gt;{props.msg}&lt;/p&gt; &lt;/div&gt; ) } &lt;!-- &lt;/div&gt; --&gt; ReactDOM.render( &lt;div&gt; &lt;MagicNumber name=&quot;m1&quot; /&gt; &lt;/div&gt;, document.getElementById(&quot;root&quot;) ); 运行结果","link":"/2018/11/27/React最佳入门/"}],"tags":[{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"This","slug":"This","link":"/tags/This/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"This","slug":"This","link":"/categories/This/"},{"name":"Sublime","slug":"Sublime","link":"/categories/Sublime/"},{"name":"Ajax","slug":"Ajax","link":"/categories/Ajax/"},{"name":"React","slug":"React","link":"/categories/React/"}]}