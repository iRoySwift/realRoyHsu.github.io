{"pages":[],"posts":[{"title":"SSH远程连接Google的Compute Engine","text":"在您的工作站上打开一个终端，再使用 ssh-keygen 命令生成新的密钥。指定 -C 标志以添加一条带有您的用户名的注释。 在您的工作站上打开一个终端，再使用 ssh-keygen 命令生成新的密钥。指定 -C 标志以添加一条带有您的用户名的注释。 1、ssh-keygen -t rsa -f ~/.ssh/[KEY_FILENAME] -C [USERNAME] 其中： [KEY_FILENAME] 是您要用于 SSH 密钥文件的名称。例如，文件名 my-ssh-key 生成一个名为 my-ssh-key 的私钥文件和一个名为 my-ssh-key.pub 公钥文件。 [USERNAME] 是您要为其应用此 SSH 密钥的用户。 该命令生成一个 SSH 私钥文件和一个匹配的 SSH 公钥，公钥结构如下所示：ssh-rsa [KEY_VALUE] [USERNAME] 其中：[KEY_VALUE] 是您生成的密钥值。[USERNAME] 是此密钥要应用到的用户。 2、限制对您的私钥的访问，以便只有您能读取此密钥，且所有人都不可向其写入。 chmod 400 ~/.ssh/[KEY_FILENAME] 其中 [KEY_FILENAME] 是您用于 SSH 密钥文件的名称。 3、要使用 ssh 连接到实例，请执行以下操作： 1、使用其中一个可用选项为实例提供 SSH 公钥。 1、cat google.pub 2、生成的公钥内容要复制出来 3、粘贴到Compute Engine的 元数据中 2、在控制台中，查找要连接到的实例的外部 IP 地址。转到您的实例列表。 3、在终端中，使用 ssh 命令和 SSH 私钥文件连接到实例。指定您的用户名和您要连接到的实例的外部 IP 地址。 ssh -i [PATH_TO_PRIVATE_KEY] [USERNAME]@[EXTERNAL_IP_ADDRESS] 其中：[PATH_TO_PRIVATE_KEY] 是您的 SSH 私钥文件的路径。[USERNAME] 是连接到实例的用户的名称。在创建 SSH 密钥时，就指定了该 SSH 公钥的用户名。如果实例具有该用户的有效 SSH 公钥，并且您拥有与之匹配的 SSH 私钥，则您可以以该用户的身份连接到此实例。[EXTERNAL_IP_ADDRESS] 是您的实例的外部 IP 地址。如果连接成功，您就可以使用终端在您的实例上运行命令。完成操作后，可使用 exit 命令断开与实例的连接。","link":"/2018/10/28/SSH远程连接Google的Compute Engine/"},{"title":"Sublime3 React、JSX 代码美化--[Prettier]","text":"最近一直用Sublime写React项目，但是jsx语法格式化一直让我头疼。尝试了JsFormat、jsfmt、HTML/CSS/JS pretty、esformatter等都没有完美的解决我的问题结果惨不忍睹： 最近一直用Sublime写React项目，但是jsx语法格式化一直让我头疼。尝试了JsFormat、jsfmt、HTML/CSS/JS pretty、esformatter等都没有完美的解决我的问题结果惨不忍睹： Prettier官网 JsPrettier is a Sublime Text Plug-in for Prettier, the opinionated code formatter.网传facebook也是在用它优化React项目 开始安装插件 -g 全局安装npm install -g prettier sublime text3 直接在package control搜索prettier下载，打开它的User配置项加入如下保存即可。 修改配置文件Preferences&gt;PackageSettings&gt;JsPrettier&gt;Settings User 1234567891011121314151617181920212223{ \"debug\": false, \"prettier_cli_path\": \"C:/Users/njwb/AppData/Roaming/npm/node_modules/prettier/bin-prettier.js\", \"node_path\": \"C:/Program Files/nodejs/node.exe\", \"auto_format_on_save\": false, \"auto_format_on_save_excludes\": [], \"allow_inline_formatting\": false, \"custom_file_extensions\": [], \"max_file_size_limit\": -1, \"additional_cli_args\": {}, \"prettier_options\": { \"printWidth\": 80, \"singleQuote\": false, \"trailingComma\": \"none\", \"bracketSpacing\": true, \"jsxBracketSameLine\": false, \"parser\": \"babylon\", \"semi\": true, \"requirePragma\": false, \"proseWrap\": \"preserve\", \"arrowParens\": \"avoid\" }} “prettier_cli_path”: 是你全局安装prettier插件的路径“node_path”: 是你nodejs安装的路径 在项目根目录下面建一个 .prettierrc 文件,并配置1234567891011{ \"printWidth\": 120, // 换行字符串阈值 \"semi\": true, // 句末加分号 \"singleQuote\": true, // 用单引号 \"trailingComma\": \"none\", // 最后一个对象元素加逗号 \"bracketSpacing\": true, // 对象，数组加空格 \"jsxBracketSameLine\": false, // jsx &gt; 是否另起一行 \"arrowParens\": \"avoid\", // (x) =&gt; {} 是否要有小括号 \"requirePragma\": false, // 是否要注释来决定是否格式化代码 \"proseWrap\": \"preserve\" // 是否要换行} 修改快捷键1234{ \"keys\": [\"ctrl+shift+j\"], \"command\": \"js_prettier\"} 如果按照本教程出现插件还是无法使用,请输入Ctrl + ·，查看控制台是否有报错它会提示你哪里有错误，Prettier官网 错可能情况有： React文件中，有单标签没有闭合：img input 配置文件中符号为中文 完美的解决了React格式化问题","link":"/2018/09/02/Sublime3 React、JSX 代码美化--[Prettier]/"},{"title":"this指向和get、set中this指向","text":"1.全局环境2.事件处理函数3.函数内部4.getter 和 setter 中 this [TOC] 1.全局环境 window 123&lt;script&gt; console.log( this ); //Window&lt;/script&gt; 1234567var box = document.getElementById(\"box\");box.onclick = function(){ setTimeout( function(){ console.log( this ); // window this.style.backgroundColor = \"red\"; },1000 )} 2.事件处理函数 DOM 事件处理函数 12345var box = document.getElementById(\"box\");box.onclick = function(){ console.log( this ); // 事件处理函数中的 this, 该事件由谁触发,this指的就是谁 //此处this返回：&lt;div id=\"box\" &gt;div&lt;/div&gt;} 内联事件处理函数 1234&lt;div id=\"box\" onclick=\"console.log( this )\" &gt;div&lt;/div&gt;&lt;!-- 此处this指向：&lt;div id=\"box\" onclick=\"console.log( this )\" &gt;div&lt;/div&gt; --&gt;&lt;div id=\"box\" onclick=\"( (function(){console.log( this )})() )\" &gt;div&lt;/div&gt;&lt;!-- 此处this指向：window --&gt; 3.函数内部 1.函数直接执行 非严格模式下 默认指向全局对象 浏览器 12345function fn(){ console.log(this);}fn();//此处this，指向windowwindow.fn();//此处this，指向window node node交互界面中 js文件中 严格模式下(前面省略window,浏览器严格模式支持) undefined 123456function fn(){ \"use strict\" console.log(this);}fn();//此处this，打印 undefinedwindow.fn();//此处this，指向window 2.call,apply和bind 把 this 的值从一个执行环境传入另一个执行环境 call apply 改变指向同时，运行函数 call 和 apply 的参数差异:apply 可以传【数组】 如果传入的不是对象会调用相对的构造函数,进行隐式转换 1234567function fn(m,n){ console.log( this.a,m,n );}fn.call( {a: 1},2,3 );// 函数.call 会直接调用该函数.// 并且call 的 第 0个参数就是 函数执行时候的this 指向第0个对象// 后面的参数是 函数执行的时候的参数 bind bind只改变指向，不会调用方法 返回一个新函数,内部this指向被修改 只会改变一次 1234567891011121314151617181920function fn(){ console.log( this.a )}fn();// this指向undefinedvar fn1 = fn.bind( {a: 2} );var fn2 = fn.bind( {a: 3} );var fn3 = fn.bind( {a: 4} );console.log( fn1 );//ƒ fn(){// console.log( this.a )// }fn1();//打印 2fn2();//打印 3fn3();//打印 4var fn4 = fn1.bind( {a:100} );fn4();//打印 2 bind只会改变一次 , 所以 还是打印 第一次bind的对象 传入数字，打印数字类型 12345function fn(){ console.log( this )}var fn1 = fn.bind(1);fn1(); //this指向 Number 3.箭头函数内部 与定义时的环境中 this 一致 点击元素定时改变 1234567891011121314&lt;div id=\"box\"&gt;box&lt;/div&gt;&lt;script&gt; var fn = ()=&gt;{ console.log( this ); // this指向window } fn(); box.onclick = function(){ console.log( this );// this指向box setTimeout( ()=&gt;{ // 箭头函数中，this指向与定义时的环境中 this 一致 //如果这个是function， this.style.backgroundColor，会报错，因为this指向window； 而window原型中没有backgroundColor this.style.backgroundColor = \"red\";//this指向box },500 ) }&lt;/script&gt; bind,call 不能修改其内部指向 全局中定义箭头函数 全局对象 12345var fn = ()=&gt;{ console.log( this )//this指向window}var fn1 = fn.bind( {} );//bind,call 不能修改其箭头函数内部指向fn1();//this指向window 对象内函数定义箭头函数 对象内部this指向window 1234567891011121314var a = 1;var obj = { a: 2, b:this, fn1: ()=&gt;{ console.log( this.a ) }, fn2: function(){ console.log( this.a ) }}console.log(obj.b);//打印window 对象内部this指向windowobj.fn1();//打印1 this指向windowobj.fn2();//打印2 this指向obj 对象内函数返回箭头函数 function函数，原则是谁调用指向谁 箭头函数，原则是在哪定义，this指向谁，并且不能被call、bind的改变指向 与上面中有所区别，对于箭头函数，return 箭头函数，里面this指向是不变的 1234567891011121314151617181920212223242526272829303132333435363738394041424344var a = 1;var obj = { a: 2, fn1: function(){ console.log( this.a )//谁调用指向谁 return function(){ console.log( this.a )//谁调用指向谁 } }, fn2: ()=&gt;{ console.log(this.a);//this指向window return ()=&gt;{ console.log( this.a );//this指向window } }, fn3: ()=&gt;{ console.log(this.a);//this指向window return function(){ console.log( this.a );//谁调用指向谁 } }, fn4: function(){ console.log(this.a);//谁调用指向谁 return ()=&gt;{ console.log( this.a );//this指向 fn4中，与function内部this指向一样 } }}var innerFn1 = obj.fn1();//打印 2console.log(innerFn1);//这里 innerFn1 = return出来的 functioninnerFn1();//打印 1 this指向window，谁调用指向谁var innerFn2 = obj.fn2();//打印 1innerFn2();//打印1 this指向windowvar innerFn3 = obj.fn3();//打印 1innerFn3();//打印1 this指向window，谁调用指向谁var innerFn4 = obj.fn4();//打印 2console.log(innerFn4);//这里 innerFn4 = return出来的 ()=&gt;{}innerFn4();//打印 2 this指向 fn4中，与function内部this指向一样 4.对象方法内部 当函数作为对象里的方法被调用时 调用该函数的对象 123456789var a = 1;var obj = { a: 2, fn: function(){ console.log( this.a ) }}obj.fn();//2obj.fn.bind({a: \"momo\"})();//momo 对象后续附属上的方法调用 调用该函数的对象 1234567891011121314var obj = { a: 1};var fn = function(){ console.log(this.a)}obj.fn = fn;//与上面中，实际一样，对象赋值，指向同一个对象obj.fn();//1//-------------------------------------var fn1 = ()=&gt;{ console.log(this.a)}obj.fn1 = fn1;obj.fn1();//undefined 箭头函数this定义时，就确定指向 作为函数内嵌套多层的方法调用 就近绑定 12345678910111213var a = 1;var obj = { a: 2, o: { a: 3, fn: function(){ console.log(this.a) } }};obj.o.fn();//3 就近绑定var temp = obj.o.fn;temp();//1 谁调用this指向谁 5.构造函数中 构造函数中没有显式return 12345function Fn(){ this.a = 10;}var f = new Fn();//this指向实例化过程，创建出来的对象 f console.log( f );//{a: 1, fn: ƒ} 构造函数中显式return return 对象 return 非对象 1234567function Fn(){ this.a = 10; //return 1; //返回非 null 的对象,那么实例化结果就是返回出的对象 Fn {a: 10} return {}; //返回非 null 的对象,那么实例化结果就是返回出的对象 {}}var f = new Fn();//this指向实例化过程，创建出来的对象 f console.log( f ); 6.原型链上函数 调用该函数的对象 1234567891011var p = { a: 1, fn: function(){ console.log( this.a ) }}var c = Object.create( p );//以p对象来复制一个对象console.log(c);//打印空对象{}console.log( c.__proto__ );//打印p对象 {a: 1, fn: ƒ}console.log( c.a );//打印1 c没有a属性，会往原型链上找c.fn();//打印1 c调用fn方法，this指向c对象，但是c上没有a属性，会往原型链上找 4.getter 和 setter 中 this get 访问 set 设置 123456789101112131415var obj = { n: 1, m: 2, get sum(){//拦截 在控制台中，obj.sum console.log( \"正在尝试访问 sum...\" ) // return 2 return this.n+this.m//这里this指向obj }, set sum(zm){//拦截 在控制台中，obj.sum = 24 console.log( \"正在设置 sum...\" ); this.n = zm/2;//这里this指向obj this.m = zm/2; }}// console.log( obj.sum )","link":"/2018/11/04/this指向和get、set中this指向/"},{"title":"关于jquery中的ajax调取数据成功回调函数，失败回调函数","text":"通常，ajax调取数据，在pc端的时候，我们不需要考虑断网情况，所以很多情况下我们都只需要如下格式： 通常，ajax调取数据，在pc端的时候，我们不需要考虑断网情况，所以很多情况下我们都只需要如下格式： 即可实现ajax调取后台数据，我这里用的是jsonp跨域调取的数据。 但是在移动端就不一样了，在app上，我们通常要考虑手机断网的情况，而我们上一段的代码中，error只是提示我们报错的原因或状态，并不能执行我们网络错误以后的回调函数，所以我们需要改动一下以上的代码。如下： 我用红线框出来的部分需要注意，在断网情况下，必须要设定timeout的值，你可以根据自己想要设定的时间，即表示在加载超过多少秒后就判断为断网了，在这里我设定的值是5秒，即在五秒后若没有获取到数据就进入失败回调函数。同时async:true必须设定为异步的形式，这里我没有进行设置即默认是异步的， 那么我们就可以在失败回调函数中进行我们想要的操作了。","link":"/2018/09/27/关于jquery中的ajax调取数据成功回调函数，失败回调函数/"}],"tags":[{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"This","slug":"This","link":"/tags/This/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"}],"categories":[{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"Sublime","slug":"Sublime","link":"/categories/Sublime/"},{"name":"This","slug":"This","link":"/categories/This/"},{"name":"Ajax","slug":"Ajax","link":"/categories/Ajax/"}]}